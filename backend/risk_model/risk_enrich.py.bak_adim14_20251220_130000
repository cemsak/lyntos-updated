from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple
from pathlib import Path
import json

from risk_model.numparse import parse_money


# Optional manual mapping:
#   risk_model/account_aliases.json
# Format: { "102.504": "HALKBANK ...", ... }
_ALIASES_CACHE: dict[str, str] | None = None


def _load_account_aliases() -> dict[str, str]:
    global _ALIASES_CACHE
    if _ALIASES_CACHE is not None:
        return _ALIASES_CACHE
    p = Path(__file__).with_name("account_aliases.json")
    if not p.exists():
        _ALIASES_CACHE = {}
        return _ALIASES_CACHE
    try:
        _ALIASES_CACHE = json.loads(p.read_text(encoding="utf-8"))
        if not isinstance(_ALIASES_CACHE, dict):
            _ALIASES_CACHE = {}
    except Exception:
        _ALIASES_CACHE = {}
    return _ALIASES_CACHE


def _lookup_account_name(metrics: dict | None, account_code: str) -> Optional[str]:
    if not metrics or not isinstance(metrics, dict):
        return None

    # 1) engine tarafında eklenen map (en doğru kaynak)
    mizan = metrics.get("mizan") or {}
    if isinstance(mizan, dict):
        name_map = mizan.get("account_name_map")
        if isinstance(name_map, dict):
            nm = name_map.get(account_code)
            if isinstance(nm, str) and nm.strip():
                return nm.strip()

    # 2) manuel alias dosyası
    aliases = _load_account_aliases()
    nm2 = aliases.get(account_code)
    if isinstance(nm2, str) and nm2.strip():
        return nm2.strip()

    return None


def _extract_kdv_matrah_by_month(metrics: dict | None) -> dict[str, float]:
    """
    metrics['beyanname']['per_type']['KDV']['per_period']['YYYY-MM']['matrah_toplami']
    """
    out: dict[str, float] = {}
    if not metrics or not isinstance(metrics, dict):
        return out

    bey = metrics.get("beyanname") or {}
    per_type = (bey.get("per_type") or {}) if isinstance(bey, dict) else {}
    kdv = (per_type.get("KDV") or {}) if isinstance(per_type, dict) else {}
    per_period = (kdv.get("per_period") or {}) if isinstance(kdv, dict) else {}
    if not isinstance(per_period, dict):
        return out

    for ym, rec in per_period.items():
        if not isinstance(ym, str):
            continue
        if not isinstance(rec, dict):
            continue
        v = rec.get("matrah_toplami")
        fv = parse_money(v)
        if fv is None:
            continue
        out[ym] = float(fv)
    return out


def _safe_ed(risk: dict) -> tuple[dict, list]:
    ed = risk.get("evidence_details")
    if not isinstance(ed, dict):
        ed = {}
        risk["evidence_details"] = ed

    warnings = ed.get("enrich_warnings")
    if warnings is None:
        warnings = []
        ed["enrich_warnings"] = warnings
    if not isinstance(warnings, list):
        warnings = [str(warnings)]
        ed["enrich_warnings"] = warnings

    return ed, warnings


def _enrich_r401a(risk: dict, metrics: dict | None, period: str | None) -> None:
    """
    Adds:
      value_found.missing_102_details = [{account_code, account_name, amount}, ...]
      evidence_details.period / rule_logic (idempotent)
      smmm_actions / checklist (idempotent)
    """
    vf = risk.get("value_found")
    if not isinstance(vf, dict):
        vf = {}
        risk["value_found"] = vf

    missing = vf.get("missing_102") or {}
    if not isinstance(missing, dict) or not missing:
        return

    # missing_102_details
    if "missing_102_details" not in vf:
        details: list[dict] = []
        for acc, amt in missing.items():
            acc_s = str(acc)
            name = _lookup_account_name(metrics, acc_s)
            a = parse_money(amt)
            details.append(
                {
                    "account_code": acc_s,
                    "account_name": name,
                    "amount": float(a) if a is not None else amt,
                }
            )
        details.sort(key=lambda x: x.get("account_code") or "")
        vf["missing_102_details"] = details

    ed, _ = _safe_ed(risk)
    if period and "period" not in ed:
        ed["period"] = period
    ed.setdefault("rule_logic", "Mizan 102.xx var AND bankada ilgili dönemde hesap hareketi yok → missing_102")

    # Actions/checklist: setdefault ile overwrite yok
    risk.setdefault(
        "smmm_actions",
        [
            "Eksik görünen 102.xx hesabın bankadaki karşılığını (IBAN/hesap no) doğrulayın.",
            "İlgili döneme ait tüm ekstre dosyalarının sisteme yüklendiğini kontrol edin (CSV/XLSX).",
            "Hesap vadeli/bloke/POS/teminat vb. bir ürünse hareketlerin farklı raporlarda tutulup tutulmadığını teyit edin (POS raporu, bloke hesap ekstresi, sanal POS).",
            "Mizan kaydı doğruysa bankadan ilgili döneme ait resmi ekstreyi temin edip sisteme ekleyin ve modeli yeniden çalıştırın.",
        ],
    )
    risk.setdefault(
        "checklist",
        [
            "İlgili dönem için banka klasöründe ilgili bankaya ait tüm ekstre dosyaları var mı?",
            "Aynı bankada birden fazla hesap/IBAN var mı (alt hesaplar farklı IBAN’lara bağlı olabilir)?",
            "Tarih parse/format nedeniyle satırlar ‘dönem dışı’ kalmış olabilir mi (özellikle gün/ay yer değişimi)?",
            "102.xx alt hesap adı POS/bloke/vadeli gibi ürünleri işaret ediyor mu?",
            "Eksik ekstre eklendikten sonra: yeniden çalıştır ve R-401A’nın kaybolduğunu doğrula.",
        ],
    )


def _median(xs: List[float]) -> Optional[float]:
    if not xs:
        return None
    xs2 = sorted(xs)
    n = len(xs2)
    mid = n // 2
    if n % 2 == 1:
        return xs2[mid]
    return (xs2[mid - 1] + xs2[mid]) / 2.0


def _enrich_r501(risk: dict, metrics: dict | None, period: str | None) -> None:
    """
    VDK-grade deterministic enrichment:
      - restore kdv_matrah_by_month
      - attach edefter sales_evidence (if exists)
      - build audit_pack + audit_dossier (month table + worst month + sample counts)
      - scale sanity checks (only warn when clearly off-scale)
    """
    ed, warnings = _safe_ed(risk)

    vf = risk.get("value_found")
    if not isinstance(vf, dict):
        vf = {}
        risk["value_found"] = vf

    # Restore KDV by month
    kdv_by = _extract_kdv_matrah_by_month(metrics)
    if kdv_by and "kdv_matrah_by_month" not in ed:
        ed["kdv_matrah_by_month"] = kdv_by
        s = sum(kdv_by.values())
        kdv_sum = parse_money(vf.get("kdv_matrah_sum"))
        if kdv_sum is not None:
            ed["kdv_matrah_sum_check"] = {
                "sum_of_months": float(s),
                "delta_vs_kdv_matrah_sum": float(s - float(kdv_sum)),
            }

    # Attach e-defter sales evidence (if present)
    edef = (metrics.get("edefter") or {}) if isinstance(metrics, dict) else {}
    se = (edef.get("sales_evidence") or {}) if isinstance(edef, dict) else {}
    if isinstance(se, dict) and se and "edefter_sales_evidence" not in ed:
        # small, safe subset (we keep the big samples in metrics['edefter']['sales_evidence'])
        ed["edefter_sales_evidence"] = {
            "sales_accounts": se.get("sales_accounts"),
            "discount_accounts": se.get("discount_accounts"),
            "per_month_sales_600_601_602": se.get("per_month_sales_600_601_602"),
            "per_month_discounts_610_611_612": se.get("per_month_discounts_610_611_612"),
            "per_month_net_sales": se.get("per_month_net_sales"),
            "totals": se.get("totals"),
        }

    # Build month_table using: KDV matrah vs e-defter net sales (preferred) else nothing
    net_by = se.get("per_month_net_sales") if isinstance(se, dict) else None
    if not isinstance(net_by, dict):
        net_by = {}

    # Months intersection/union strategy: we want KDV months primarily
    months = sorted(set(kdv_by.keys()) | set(net_by.keys()))
    month_table: List[dict] = []
    ratios: List[float] = []

    def _f(x: Any) -> float:
        v = parse_money(x)
        return float(v) if v is not None else 0.0

    for mm in months:
        k = _f(kdv_by.get(mm))
        net = _f(net_by.get(mm))
        delta = net - k
        ratio = (net / k) if k not in (0.0, -0.0) else None
        if ratio is not None:
            ratios.append(float(ratio))
        month_table.append(
            {
                "month": mm,
                "kdv_matrah": float(k),
                "edefter_net_sales": float(net),
                "delta_net_minus_kdv": float(delta),
                "ratio_net_over_kdv": float(ratio) if ratio is not None else None,
            }
        )

    # Find worst month by absolute delta magnitude (only if we have months)
    worst_month = None
    worst_row = None
    if month_table:
        worst_row = max(month_table, key=lambda r: abs(float(r.get("delta_net_minus_kdv") or 0.0)))
        worst_month = worst_row.get("month")

    # Scale sanity check (catch only “obvious 100x/10.000x” cases)
    scale_flag = None
    scale_stats = None
    if ratios:
        rmin = min(ratios)
        rmax = max(ratios)
        rmed = _median(ratios)
        scale_stats = {"ratio_min": rmin, "ratio_median": rmed, "ratio_max": rmax}

        # RED only if clearly off (e.g., 20x+ or 0.02x-)
        if (rmed is not None) and (rmed > 20.0 or rmed < 0.02):
            scale_flag = "RED"
        # YELLOW if suspicious but not insane
        elif (rmed is not None) and (rmed > 5.0 or rmed < 0.20):
            scale_flag = "YELLOW"

        if scale_flag == "RED":
            warnings.append(
                f"R-501 scale anomaly (RED): e-defter net satış / KDV matrah oranı beklenmedik. stats={scale_stats}"
            )

    # Sample counts (from metrics, not duplicating big payload)
    samples_sales = (se.get("samples_sales_by_month") or {}) if isinstance(se, dict) else {}
    samples_kdv = (se.get("samples_kdv_by_month") or {}) if isinstance(se, dict) else {}
    sales_cnt = sum(len(v or []) for v in samples_sales.values()) if isinstance(samples_sales, dict) else 0
    kdv_cnt = sum(len(v or []) for v in samples_kdv.values()) if isinstance(samples_kdv, dict) else 0

    # audit_pack (lightweight)
    audit_pack = {
        "period": period,
        "month_table": month_table,
        "worst_month": worst_month,
        "worst_month_details": worst_row,
        "samples_counts": {"sales": int(sales_cnt), "kdv": int(kdv_cnt)},
        "scale_flag": scale_flag,
        "scale_stats": scale_stats,
        "note": "Ay bazında e-defter net satış ↔ KDV matrah farkı; delil seçimi ve kök neden analizi için yön verir.",
    }
    ed["audit_pack"] = audit_pack

    # audit_dossier (VDK paket formatı – deterministic, printable)
    ed["audit_dossier"] = {
        "version": "VDK-AUDITDOSSIER/1.0",
        "period": period,
        "risk_code": risk.get("code"),
        "title": risk.get("title"),
        "severity": risk.get("severity"),
        "headline": "KDV matrahı ile satışlar (e-defter net satış referansı) arasında ay bazında mutabakat analizi.",
        "evidence_pack": {
            "samples_counts": {"sales": int(sales_cnt), "kdv": int(kdv_cnt)},
            "worst_month": worst_month,
            "month_table": month_table,
            "scale_flag": scale_flag,
            "scale_stats": scale_stats,
        },
        "samples_counts": {"sales": int(sales_cnt), "kdv": int(kdv_cnt)},
        "worst_month": worst_month,
        "month_table": month_table,
        "reconciliation_plan": ed.get("vdK_reconciliation_plan")
        or [
            "KDV matrahının toplandığı beyan dönemlerini doğrula (örn. 2025-04/05/06).",
            "Satışları brüt→net etkileyen 610/611/612 (iskonto/iade) kayıtlarını kontrol et.",
            "İstisna/tevkifat satışlarını beyanname kırılımlarıyla karşılaştır.",
            "Dönem kayması ve yanlış hesap sınıflaması ihtimalini ay bazında test et.",
            "En kötü ay için 5–10 yevmiye fişi/fatura örneğini delil olarak seç ve doğrula.",
        ],
    }

    # mark that we applied deterministic policy
    ed["severity_policy_applied"] = True


def enrich_rules_in_metrics(metrics: Dict[str, Any], period: Optional[str] = None) -> Dict[str, Any]:
    """
    Entry point imported by v1_engine.py

    Mutates metrics['rules']['risks'][*] in-place.
    Also sets metrics['rules']['enriched']=True/False and ['enrich_error']=... for observability.
    """
    rules = metrics.get("rules")
    if not isinstance(rules, dict):
        return metrics

    try:
        risks = rules.get("risks") or []
        if not isinstance(risks, list):
            risks = []

        for r in risks:
            if not isinstance(r, dict):
                continue
            code = r.get("code")
            if code == "R-401A":
                _enrich_r401a(r, metrics, period)
            elif code == "R-501":
                _enrich_r501(r, metrics, period)

        rules["enriched"] = True
        rules["enrich_error"] = None
        return metrics
    except Exception as e:
        rules["enriched"] = False
        rules["enrich_error"] = f"{e.__class__.__name__}: {e}"
        return metrics
