from __future__ import annotations

from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Dict, List, Optional

from data_engine.loader import load_all_for_client_period


Number = float  # sade okunurluk için


@dataclass
class RiskScores:
    kurgan_risk: Number
    tax_compliance: Number
    smiyb_risk: Number
    radar_risk: Number
    edefter_risk: Number
    inflation_risk: Number


def _safe_float(value: Any, default: Number = 0.0) -> Number:
    if value is None:
        return default
    try:
        return float(str(value).replace(",", "."))
    except Exception:
        return default


def _first_digit(hesap_kodu: str) -> Optional[str]:
    if not hesap_kodu:
        return None
    for ch in str(hesap_kodu):
        if ch.isdigit():
            return ch
    return None


def _clamp(value: Number, lo: Number = 0.0, hi: Number = 100.0) -> Number:
    return max(lo, min(hi, value))


# ---------------------------------------------------------------------
# 1) BEYANNAME METRİKLERİ
# ---------------------------------------------------------------------
def compute_beyanname_metrics(beyan_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Beyannameleri tür ve dönem bazında özetler.

    Çıktı:
    {
      "per_type": {
          "KDV": {
              "per_period": { "2025-04": {...}, ... },
              "summary": {...}
          },
          ...
      },
      "periods": ["2025-04", "2025-05", ...]
    }
    """
    per_type: Dict[str, Dict[str, Dict[str, Any]]] = {}
    periods: set[str] = set()

    for rec in beyan_list:
        btype = rec.get("beyan_type") or "UNKNOWN"
        period = rec.get("period")  # e.g. "2025-06"
        details = rec.get("details") or {}
        if not period:
            continue
        periods.add(period)
        per_type.setdefault(btype, {}).setdefault("per_period", {})

        if btype == "KDV":
            per_type[btype]["per_period"][period] = {
                "matrah_toplami": _safe_float(details.get("matrah_toplami")),
                "hesaplanan_kdv": _safe_float(details.get("hesaplanan_kdv")),
                "toplam_kdv": _safe_float(details.get("toplam_kdv")),
                "onceki_devreden_ind_kdv": _safe_float(details.get("onceki_devreden_ind_kdv")),
                "indirimler_toplami": _safe_float(details.get("indirimler_toplami")),
            }
        elif btype == "KDV2":
            per_type[btype]["per_period"][period] = {
                "matrah": _safe_float(details.get("matrah")),
                "tevkif_edilen_kdv": _safe_float(details.get("tevkif_edilen_kdv")),
                "odenecek_kdv": _safe_float(details.get("odenecek_kdv")),
            }
        elif btype == "MUHTASAR":
            per_type[btype]["per_period"][period] = {
                "mahsup_edilecek_toplam_vergi": _safe_float(details.get("mahsup_edilecek_toplam_vergi")),
                "tevkifata_iliskin_damga_vergisi": _safe_float(details.get("tevkifata_iliskin_damga_vergisi")),
            }
        elif btype == "GECICI_KV":
            per_type[btype]["per_period"][period] = {
                "ticari_bilanco_kari": _safe_float(details.get("ticari_bilanco_kari")),
                "ticari_bilanco_zarari": _safe_float(details.get("ticari_bilanco_zarari")),
                "gecici_vergi_matrahi": _safe_float(details.get("gecici_vergi_matrahi")),
                "hesaplanan_gecici_vergi": _safe_float(details.get("hesaplanan_gecici_vergi")),
            }
        else:
            # bilinmeyen tipleri ham detayla saklıyoruz
            per_type[btype]["per_period"][period] = {
                "raw": details
            }

    # Özetler
    for btype, data in per_type.items():
        per_period = data.get("per_period", {})
        summary: Dict[str, Number] = {}
        for pvals in per_period.values():
            for key, val in pvals.items():
                if isinstance(val, (int, float)):
                    summary[key + "_sum"] = summary.get(key + "_sum", 0.0) + float(val)
        per_type[btype]["summary"] = summary

    return {
        "per_type": per_type,
        "periods": sorted(periods),
    }


# ---------------------------------------------------------------------
# 2) TAHAKKUK METRİKLERİ
# ---------------------------------------------------------------------
def compute_tahakkuk_metrics(thk_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    per_type: Dict[str, Dict[str, Dict[str, Any]]] = {}
    periods: set[str] = set()

    for rec in thk_list:
        ttype = rec.get("tax_type") or "UNKNOWN"
        period = rec.get("period")
        if not period:
            continue
        periods.add(period)
        per_type.setdefault(ttype, {}).setdefault("per_period", {})

        main_row = rec.get("main_row") or {}
        per_type[ttype]["per_period"][period] = {
            "matrah": _safe_float(main_row.get("matrah")),
            "tahakkuk_eden": _safe_float(main_row.get("tahakkuk_eden")),
            "mahsup_edilen": _safe_float(main_row.get("mahsup_edilen")),
            "odenecek_olan": _safe_float(main_row.get("odenecek_olan")),
            "total_payable": _safe_float(rec.get("total_payable")),
            "acceptance_date": rec.get("acceptance_date"),
            "issue_date": rec.get("issue_date"),
            "vade": (main_row.get("vade") or ""),
        }

    # özetler
    for ttype, data in per_type.items():
        per_period = data.get("per_period", {})
        summary: Dict[str, Number] = {}
        for pvals in per_period.values():
            for key, val in pvals.items():
                if isinstance(val, (int, float)):
                    summary[key + "_sum"] = summary.get(key + "_sum", 0.0) + float(val)
        per_type[ttype]["summary"] = summary

    return {
        "per_type": per_type,
        "periods": sorted(periods),
    }


# ---------------------------------------------------------------------
# 3) MİZAN METRİKLERİ (yapısal / radar için)
# ---------------------------------------------------------------------
def compute_mizan_metrics(mizan_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Mizan satırlarından ana sınıf bazlı özetler üretir.
    """
    class_sums: Dict[str, Dict[str, Number]] = {}
    kdv_accounts: Dict[str, Number] = {}
    equity_total = 0.0

    for row in mizan_list:
        code = str(row.get("hesap_kodu") or "")
        first = _first_digit(code)
        bakiye_borc = _safe_float(row.get("bakiye_borc"))
        bakiye_alacak = _safe_float(row.get("bakiye_alacak"))
        net = bakiye_borc - bakiye_alacak

        if first:
            cs = class_sums.setdefault(first, {"bakiye_borc": 0.0, "bakiye_alacak": 0.0, "net": 0.0})
            cs["bakiye_borc"] += bakiye_borc
            cs["bakiye_alacak"] += bakiye_alacak
            cs["net"] += net

        # KDV ilişkili hesaplar
        if code.startswith("191") or code.startswith("190") or code.startswith("360"):
            kdv_accounts[code] = kdv_accounts.get(code, 0.0) + net

        # Özkaynak sınıfı (5xx)
        if code.startswith("5"):
            equity_total += net

    assets_net = class_sums.get("1", {}).get("net", 0.0) + class_sums.get("2", {}).get("net", 0.0)
    liab_net = (
        class_sums.get("3", {}).get("net", 0.0)
        + class_sums.get("4", {}).get("net", 0.0)
        + class_sums.get("5", {}).get("net", 0.0)
    )

    # Basit likidite göstergeleri
    cash_bank = 0.0
    receivables = 0.0
    inventory = 0.0
    short_term_liab = 0.0

    for row in mizan_list:
        code = str(row.get("hesap_kodu") or "")
        net = _safe_float(row.get("bakiye_borc")) - _safe_float(row.get("bakiye_alacak"))

        if code.startswith(("10", "100", "101", "102")):
            cash_bank += net
        if code.startswith(("12", "120", "121")):
            receivables += net
        if code.startswith(("15", "150", "153")):
            inventory += net
        if code.startswith(("30", "300", "320", "321", "329", "33", "331", "332", "333", "336")):
            short_term_liab += abs(net)

    total_current_assets = cash_bank + receivables + inventory

    return {
        "class_sums": class_sums,
        "assets_net": assets_net,
        "liabilities_equity_net": liab_net,
        "equity_total": equity_total,
        "cash_bank": cash_bank,
        "receivables": receivables,
        "inventory": inventory,
        "short_term_liabilities": short_term_liab,
        "total_current_assets": total_current_assets,
        "kdv_accounts": kdv_accounts,
    }


# ---------------------------------------------------------------------
# 4) BANKA METRİKLERİ
# ---------------------------------------------------------------------
def compute_banka_metrics(banka_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Banka hareketlerinden özet metrikler.
    Not: Bu katman hukuki yorum yapmaz; sadece sınıflandırma + sayısal özet üretir.
    """
    from datetime import datetime

    def parse_date(s: str):
        s = (s or "").strip()
        for fmt in ("%d.%m.%Y", "%d/%m/%Y", "%Y-%m-%d"):
            try:
                return datetime.strptime(s, fmt).date()
            except Exception:
                pass
        return None

    total_borc = 0.0
    total_alacak = 0.0
    pos_inflows = 0.0
    bank_fees = 0.0

    # “Kesin” vergi ödemesi: bankada VERGI- / VERGİ- ile gelen tahsilatlar (senin datanda çok net).
    tax_payments_gib_confirmed = 0.0
    tax_confirmed_rows = []

    # SGK ödemeleri
    sgk_payments = 0.0
    sgk_samples = []

    # Banka kaynaklı vergi-benzeri kesintiler (BSMV vb) – bunlar GİB vergi ödemesi değildir.
    bank_tax_like_charges = 0.0
    bank_tax_like_samples = []

    bank_row_count = 0
    bank_date_min = None
    bank_date_max = None

    for row in banka_list:
        bank_row_count += 1

        d = parse_date(row.get("tarih") or "")
        if d:
            bank_date_min = d if (bank_date_min is None or d < bank_date_min) else bank_date_min
            bank_date_max = d if (bank_date_max is None or d > bank_date_max) else bank_date_max

        borc = _safe_float(row.get("borc"))
        alacak = _safe_float(row.get("alacak"))
        desc_raw = (row.get("aciklama") or "")
        desc = desc_raw.upper()

        total_borc += borc
        total_alacak += alacak

        # POS inflow (ciro proxysi)
        if "POS" in desc or "PESINSATIS" in desc or "PEŞİNSATIŞ" in desc or "TAKSİTSATIŞ" in desc:
            pos_inflows += alacak

        # bank fees / commissions
        if ("ÜYE İŞYERİ ÜCRETİ" in desc) or ("KOMİSYON" in desc) or ("MASRAF" in desc):
            bank_fees += borc

        # bank tax-like charges (BSMV/BSMV vb)
        if ("BSMV" in desc) or ("BESMV" in desc):
            bank_tax_like_charges += borc
            if len(bank_tax_like_samples) < 20:
                bank_tax_like_samples.append({
                    "tarih": d.isoformat() if d else None,
                    "tutar": borc,
                    "aciklama": desc_raw[:160],
                })

        # confirmed tax payments (VERGI- pattern)
        if ("VERGI-" in desc) or ("VERGİ-" in desc):
            tax_payments_gib_confirmed += borc
            if len(tax_confirmed_rows) < 500:
                tax_confirmed_rows.append({
                    "tarih": d.isoformat() if d else None,
                    "borc": borc,
                    "aciklama": desc_raw[:200],
                })

        # SGK
        if "SGK" in desc:
            sgk_payments += borc
            if len(sgk_samples) < 20:
                sgk_samples.append({
                    "tarih": d.isoformat() if d else None,
                    "tutar": borc,
                    "aciklama": desc_raw[:200],
                })

    return {
        "total_borc": total_borc,
        "total_alacak": total_alacak,
        "net_change": total_alacak - total_borc,

        "pos_inflows": pos_inflows,
        "bank_fees": bank_fees,

        "bank_row_count": bank_row_count,
        "bank_date_min": bank_date_min.isoformat() if bank_date_min else None,
        "bank_date_max": bank_date_max.isoformat() if bank_date_max else None,

        "tax_payments_gib_confirmed": tax_payments_gib_confirmed,
        "tax_confirmed_rows": tax_confirmed_rows,

        "sgk_payments": sgk_payments,
        "sgk_samples": sgk_samples,

        "bank_tax_like_charges": bank_tax_like_charges,
        "bank_tax_like_samples": bank_tax_like_samples,
    }


def compute_edefter_metrics(edefter_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    total_lines = len(edefter_list)
    kdv_lines = 0
    fx_lines = 0
    inflation_lines = 0

    for row in edefter_list:
        code = str(row.get("hesap_kodu") or "")
        name = (row.get("hesap_adi") or "").upper()
        aciklama = (row.get("aciklama") or "").upper()
        detay = (row.get("detay") or "").upper()

        text = name + " " + aciklama + " " + detay

        if code.startswith(("190", "191", "360")) or "KDV" in text:
            kdv_lines += 1

        if any(token in text for token in ["USD", "EUR", "DOLAR", "EURO", "STERLIN"]):
            fx_lines += 1

        if "ENFLASYON" in text or "DÜZELTME" in text or "ENF.DÜZ" in text:
            inflation_lines += 1

    return {
        "total_lines": total_lines,
        "kdv_lines": kdv_lines,
        "fx_lines": fx_lines,
        "inflation_lines": inflation_lines,
        "kdv_line_ratio": (kdv_lines / total_lines) if total_lines else 0.0,
    }


# ---------------------------------------------------------------------
# 6) TUTARLILIK / UYUM METRİKLERİ (Beyan + Tahakkuk + Banka)
# ---------------------------------------------------------------------
def compute_consistency_metrics(
    beyan_metrics: Dict[str, Any],
    thk_metrics: Dict[str, Any],
    banka_metrics: Dict[str, Any],
) -> Dict[str, Any]:
    """
    1) Beyanname ↔ Tahakkuk (karşılaştırılabilir kalemler) farkları
    2) Tahakkuk yükümlülükleri ↔ Banka "confirmed tax" satırları eşleştirmesi
       - Banka verisi eksik dönemi kapsıyorsa: 'unverifiable' olarak işaretler.
    """
    from datetime import datetime, timedelta

    def parse_date(s: str):
        s = (s or "").strip()
        for fmt in ("%d.%m.%Y", "%d/%m/%Y", "%Y-%m-%d"):
            try:
                return datetime.strptime(s, fmt).date()
            except Exception:
                pass
        return None

    per_type_b = beyan_metrics.get("per_type", {}) or {}
    per_type_t = thk_metrics.get("per_type", {}) or {}

    # --------------------------
    # (1) BEYAN ↔ TAHAKKUK farkı
    # --------------------------
    mismatch_total = 0.0
    mismatch_max = 0.0
    mismatch_over_100 = 0
    missing_beyan = 0
    missing_thk = 0
    mismatch_details = []

    # Not: MUHTASAR beyan detayları şu an tam değil (sende sadece damga var), bu yüzden mismatch’te MUHTASAR’ı şimdilik dışarıda tutuyoruz.
    comparable_codes = ["KDV", "KDV2", "GECICI_KV"]

    for code in comparable_codes:
        b_data = per_type_b.get(code, {}) or {}
        t_data = per_type_t.get(code, {}) or {}
        b_pp = b_data.get("per_period", {}) or {}
        t_pp = t_data.get("per_period", {}) or {}

        all_periods = set(b_pp.keys()) | set(t_pp.keys())
        for period in sorted(all_periods):
            b_val = None
            t_val = None

            if period in b_pp:
                b = b_pp[period] or {}
                if code == "KDV":
                    b_val = _safe_float(b.get("toplam_kdv"))
                elif code == "KDV2":
                    b_val = _safe_float(b.get("odenecek_kdv"))
                elif code == "GECICI_KV":
                    b_val = _safe_float(b.get("hesaplanan_gecici_vergi"))
            else:
                missing_beyan += 1

            if period in t_pp:
                t = t_pp[period] or {}
                if code == "KDV":
                    t_val = _safe_float(t.get("tahakkuk_eden"))
                elif code == "KDV2":
                    t_val = _safe_float(t.get("odenecek_olan")) or _safe_float(t.get("tahakkuk_eden"))
                elif code == "GECICI_KV":
                    t_val = _safe_float(t.get("tahakkuk_eden"))
            else:
                missing_thk += 1

            if b_val is None or t_val is None:
                continue

            diff = abs(b_val - t_val)
            mismatch_total += diff
            mismatch_max = max(mismatch_max, diff)
            if diff > 100.0:
                mismatch_over_100 += 1

            if diff > 0:
                mismatch_details.append({
                    "type": code,
                    "period": period,
                    "beyan": b_val,
                    "tahakkuk": t_val,
                    "diff": diff,
                })

    # -------------------------------------------------
    # (2) TAHAKKUK yükümlülükleri ↔ BANKA eşleştirmesi
    # -------------------------------------------------
    bank_min = parse_date(banka_metrics.get("bank_date_min") or "")
    bank_max = parse_date(banka_metrics.get("bank_date_max") or "")

    confirmed_rows = banka_metrics.get("tax_confirmed_rows", []) or []
    bank_tax_rows = []
    for r in confirmed_rows:
        d = parse_date(r.get("tarih") or "")
        if not d:
            continue
        bank_tax_rows.append({
            "tarih": d,
            "borc": _safe_float(r.get("borc")),
            "aciklama": (r.get("aciklama") or "")[:200],
        })

    tol = 2.0
    window_days = 10

    obligations = []
    for ttype, data in (per_type_t.items() if isinstance(per_type_t, dict) else []):
        pp = (data or {}).get("per_period", {}) or {}
        for period, r in pp.items():
            r = r or {}
            vade = parse_date(r.get("vade") or "")
            if not vade:
                continue

            cash = _safe_float(r.get("odenecek_olan"))
            total = _safe_float(r.get("total_payable"))

            # eşleştirmede: cash>0 ise cash, değilse total_payable
            expected = cash if cash > 0 else total
            if expected <= 0:
                continue

            lo = vade - timedelta(days=window_days)
            hi = vade + timedelta(days=window_days)

            verifiable = True
            reason = None
            if bank_min is None or bank_max is None:
                verifiable = False
                reason = "bank_date_range_missing"
            else:
                if bank_max < lo or bank_min > hi:
                    verifiable = False
                    reason = "bank_range_outside_window"

            matches = []
            if verifiable:
                for br in bank_tax_rows:
                    if lo <= br["tarih"] <= hi and abs(br["borc"] - expected) <= tol:
                        matches.append({"tarih": br["tarih"].isoformat(), "borc": br["borc"], "aciklama": br["aciklama"]})

            obligations.append({
                "type": ttype,
                "period": period,
                "vade": vade.isoformat(),
                "expected": expected,
                "window_lo": lo.isoformat(),
                "window_hi": hi.isoformat(),
                "verifiable": verifiable,
                "reason": reason,
                "match_count": len(matches),
                "match_sample": matches[0] if matches else None,
            })

    # bank_data_sufficient: tüm yükümlülük pencerelerini kapsıyor mu?
    bank_data_sufficient = False
    if obligations and bank_min and bank_max:
        all_lo = min(parse_date(o["window_lo"]) for o in obligations)
        all_hi = max(parse_date(o["window_hi"]) for o in obligations)
        bank_data_sufficient = (bank_min <= all_lo and bank_max >= all_hi)

    verifiable_obs = [o for o in obligations if o["verifiable"]]
    unverifiable_obs = [o for o in obligations if not o["verifiable"]]
    matched_obs = [o for o in verifiable_obs if o["match_count"] > 0]
    unmatched_obs = [o for o in verifiable_obs if o["match_count"] == 0]

    expected_sum = sum(o["expected"] for o in verifiable_obs)
    matched_sum = 0.0
    for o in matched_obs:
        ms = o.get("match_sample") or {}
        matched_sum += _safe_float(ms.get("borc"))

    coverage_rate = None
    if expected_sum > 0:
        coverage_rate = matched_sum / expected_sum

    return {
        # beyan ↔ tahakkuk (karşılaştırılabilir kalemler)
        "beyan_tahakkuk_mismatch_total": mismatch_total,
        "beyan_tahakkuk_mismatch_max": mismatch_max,
        "beyan_tahakkuk_mismatch_over_100": mismatch_over_100,
        "missing_beyan_count": missing_beyan,
        "missing_tahakkuk_count": missing_thk,
        "mismatch_details": mismatch_details[:50],

        # banka kapsama bilgisi
        "bank_date_min": bank_min.isoformat() if bank_min else None,
        "bank_date_max": bank_max.isoformat() if bank_max else None,
        "bank_data_sufficient": bank_data_sufficient,

        # eşleştirme özeti (confirmed tax rows üzerinden)
        "obligation_count": len(obligations),
        "verifiable_obligation_count": len(verifiable_obs),
        "unverifiable_obligation_count": len(unverifiable_obs),
        "matched_obligation_count": len(matched_obs),
        "unmatched_obligation_count": len(unmatched_obs),
        "expected_sum_verifiable": expected_sum,
        "matched_sum_verifiable": matched_sum,
        "tax_payment_coverage_rate": coverage_rate,

        # debug için kısa rapor
        "payment_matching": obligations[:80],
    }


def compute_scores(metrics: Dict[str, Any]) -> RiskScores:
    beyan = metrics.get("beyanname", {})
    mizan = metrics.get("mizan", {})
    banka = metrics.get("banka", {})
    edefter = metrics.get("edefter", {})
    cons = metrics.get("consistency", {})

    # --- Vergi uyum skoru (100 = iyi uyum, 0 = kötü uyum) ---
    tax_compliance = 100.0

    mismatch_total = _safe_float(cons.get("beyan_tahakkuk_mismatch_total"))
    mismatch_over_100 = int(cons.get("beyan_tahakkuk_mismatch_over_100") or 0)
    missing_forms = int(cons.get("missing_beyan_count") or 0) + int(cons.get("missing_tahakkuk_count") or 0)  # noqa
    coverage_rate = cons.get("tax_payment_coverage_rate")
    bank_ok = bool(cons.get("bank_data_sufficient"))
    verifiable = int(cons.get("verifiable_obligation_count") or 0)

    # Banka verisi dönem açısından yeterli değilse coverage_rate cezası uygulamayız.

    # Beyan–tahakkuk tutarlılığı: fark büyüdükçe uyum düşer
    tax_compliance -= min(40.0, mismatch_total / 1000.0 * 5.0)
    tax_compliance -= mismatch_over_100 * 5.0
    tax_compliance -= missing_forms * 10.0

    # Ödeme kapsamı: sadece "eksik ödeme" sinyalinde düşür.
    # coverage_rate > 1 çoğu zaman dönem kayması / sınıflandırma genişliği nedeniyle olabilir.
    if bank_ok and verifiable > 0 and coverage_rate is not None and coverage_rate < 0.95:
        tax_compliance -= 20.0

    tax_compliance = _clamp(tax_compliance)

    # KURGAN harmanı risk üzerinden yapılır (0 iyi, 100 kötü)
    tax_risk = 100.0 - tax_compliance

    # --- E-defter skoru ---
    total_lines = int(edefter.get("total_lines") or 0)
    kdv_ratio = _safe_float(edefter.get("kdv_line_ratio"))
    fx_lines = int(edefter.get("fx_lines") or 0)
    inflation_lines = int(edefter.get("inflation_lines") or 0)

    if total_lines == 0:
        edefter_score = 90.0  # veri yok → yüksek risk
    else:
        edefter_score = 30.0
        if kdv_ratio < 0.02:
            edefter_score += 20.0  # KDV ile ilgili satır oranı çok düşük
        if fx_lines > 0 and inflation_lines == 0:
            edefter_score += 20.0  # döviz var ama enflasyon/düzeltme izi yok
        if total_lines > 20000:
            edefter_score += 10.0  # çok büyük yevmiye → karmaşıklık

    edefter_score = _clamp(edefter_score)

    # --- SMİYB riski (sadece sayısal pattern) ---
    b_kdv = beyan.get("per_type", {}).get("KDV", {}).get("summary", {})
    b_kdv2 = beyan.get("per_type", {}).get("KDV2", {}).get("summary", {})
    kdv_matrah = _safe_float(b_kdv.get("matrah_toplami_sum"))
    kdv2_matrah = _safe_float(b_kdv2.get("matrah_sum"))
    pos_inflows = _safe_float(banka.get("pos_inflows"))
    receivables = _safe_float(mizan.get("receivables"))

    smiyb_score = 25.0
    if kdv_matrah > 0:
        ratio_kdv2 = kdv2_matrah / kdv_matrah
        if ratio_kdv2 > 0.1:
            smiyb_score += min(30.0, (ratio_kdv2 - 0.1) * 100.0)  # 0.4+ seviyede ekstra puan

    approx_turnover = kdv_matrah
    if approx_turnover > 0 and pos_inflows > approx_turnover * 1.2:
        smiyb_score += 20.0  # POS cirosu beyana göre çok yüksek

    if receivables > approx_turnover * 1.5:
        smiyb_score += 10.0  # alacaklar satışa göre çok yüksek

    smiyb_score = _clamp(smiyb_score)

    # --- Radar / yapısal risk ---
    total_current_assets = _safe_float(mizan.get("total_current_assets"))
    short_term_liab = _safe_float(mizan.get("short_term_liabilities"))
    equity_total = _safe_float(mizan.get("equity_total"))

    radar_score = 30.0
    if total_current_assets and short_term_liab:
        current_ratio = total_current_assets / short_term_liab
        if current_ratio < 1.0:
            radar_score += 25.0
        elif current_ratio < 1.2:
            radar_score += 15.0
        elif current_ratio < 1.5:
            radar_score += 5.0

    if equity_total <= 0:
        radar_score += 20.0  # negatif veya çok düşük özkaynak

    radar_score = _clamp(radar_score)

    # --- Enflasyon / kur risk skoru (kabaca, hukuki görüş değil) ---
    fx_lines = int(edefter.get("fx_lines") or 0)
    inflation_lines = int(edefter.get("inflation_lines") or 0)
    fx_exposed = fx_lines > 0

    inflation_score = 30.0
    if fx_exposed and inflation_lines == 0:
        inflation_score += 30.0  # döviz var, düzeltme izi yok
    elif fx_exposed and inflation_lines > 0:
        inflation_score += 10.0
    else:
        inflation_score += 5.0  # döviz yok → yine de genel enflasyon kontrolü gerekir

    inflation_score = _clamp(inflation_score)

    # --- Genel KURGAN skoru (blend) ---
    kurgan = (
        tax_risk * 0.3
        + smiyb_score * 0.25
        + radar_score * 0.2
        + edefter_score * 0.15
        + inflation_score * 0.1
    )

    kurgan = _clamp(kurgan)

    return RiskScores(
        kurgan_risk=kurgan,
        tax_compliance=tax_compliance,
        smiyb_risk=smiyb_score,
        radar_risk=radar_score,
        edefter_risk=edefter_score,
        inflation_risk=inflation_score,
    )


# ---------------------------------------------------------------------
# 8) KURAL TABANLI AI METİN KATI
# ---------------------------------------------------------------------
def build_ai_layer(
    smmm_id: str,
    client_id: str,
    period: str,
    metrics: Dict[str, Any],
    scores: RiskScores,
) -> Dict[str, Any]:
    """
    Dış LLM çağrısı yapmadan kural tabanlı Türkçe özet üretir.
    Hukuki sonuç cümlesi üretmez, sadece SMMM için checklist / tavsiye üretir.
    """
    cons = metrics.get("consistency", {})
    mizan = metrics.get("mizan", {})
    edefter = metrics.get("edefter", {})

    def fmt_pct(x: Optional[Number]) -> str:
        if x is None:
            return "-"
        return f"{x*100:.1f}%"

    coverage_rate = cons.get("tax_payment_coverage_rate")
    coverage_txt = fmt_pct(coverage_rate) if coverage_rate is not None else "-"

    summary_lines: List[str] = []

    summary_lines.append(
        f"{client_id} için {period} dönemi verileri (beyanname, tahakkuk, mizan, banka, e-defter) birlikte analiz edildi."
    )
    summary_lines.append(
        f"Kurgan toplam risk skoru: {scores.kurgan_risk:.1f} / 100 "
        f"(Vergi uyumu: {scores.tax_compliance:.1f}, SMİYB: {scores.smiyb_risk:.1f}, "
        f"Yapısal radar: {scores.radar_risk:.1f}, E-defter: {scores.edefter_risk:.1f}, Enflasyon: {scores.inflation_risk:.1f})."
    )
    if coverage_rate is not None:
        summary_lines.append(
            f"Tahakkuk eden vergilerin banka hareketleri üzerinden ödeme kapsam oranı yaklaşık {coverage_txt} seviyesinde."
        )

    # Checklist
    checklist: List[str] = []
    if _safe_float(cons.get("beyan_tahakkuk_mismatch_total")) > 0:
        checklist.append(
            "Beyanname ile tahakkuk tutarları arasındaki farkları (özellikle 100 TL üzeri olanları) tek tek kontrol edin."
        )
    if coverage_rate is not None and (coverage_rate < 0.95 or coverage_rate > 1.05):
        checklist.append(
            "Banka hesap hareketlerinde vergi dairesi ödemeleri ile tahakkuk toplamlarını karşılaştırın; eksik veya fazla ödeme var mı?"
        )
    if _safe_float(mizan.get("equity_total")) <= 0:
        checklist.append(
            "Özkaynakların negatif veya çok zayıf olup olmadığını kontrol edin; sermaye tamamlama / güçlendirme ihtiyacını değerlendirin."
        )
    if int(edefter.get("fx_lines") or 0) > 0 and int(edefter.get("inflation_lines") or 0) == 0:
        checklist.append(
            "Dövizli işlemler için kur değerlemesi ve enflasyon muhasebesi kayıtlarının (varsa) doğru yapıldığını doğrulayın."
        )
    if not checklist:
        checklist.append(
            "Bu dönem için kritik bir alarm görünmüyor; yine de örnekleme yoluyla birkaç beyanname, banka hareketi ve yevmiye kaydını manuel kontrol edin."
        )

    advice_lines: List[str] = []
    advice_lines.append(
        "Bu çıktı, sayısal tutarlılık ve oran analizi yapar; hukuki nitelikte bir vergi görüşü değildir."
    )
    advice_lines.append(
        "Herhangi bir önemli fark veya yüksek risk görülen alan için, ilgili beyannameleri, tahakkuk fişlerini ve e-defter kayıtlarını resmi mevzuat çerçevesinde detaylı inceleyin."
    )
    advice_lines.append(
        "Özellikle enflasyon muhasebesi ve kur değerlemesi konularında, güncel Vergi Usul Kanunu düzenlemeleri ve Gelir İdaresi Başkanlığı özelgeleri esas alınmalıdır."
    )

    return {
        "summary": "\n".join(summary_lines),
        "checklist": "\n".join(f"- {item}" for item in checklist),
        "advice": "\n".join(advice_lines),
    }


# ---------------------------------------------------------------------
# 9) DIŞA AÇILAN ANA FONKSİYON
# ---------------------------------------------------------------------
def run_risk_model_v1(
    base_dir: str | Path,
    smmm_id: str,
    client_id: str,
    period: str,
) -> Dict[str, Any]:
    """
    FastAPI endpoint'inin çağıracağı üst seviye fonksiyon.
    """
    base_path = Path(base_dir)
    raw = load_all_for_client_period(
        base_dir=base_path,
        smmm_id=smmm_id,
        client_id=client_id,
        period=period,
    )

    beyan_metrics = compute_beyanname_metrics(raw.get("beyanname", []))
    thk_metrics = compute_tahakkuk_metrics(raw.get("tahakkuk", []))
    mizan_metrics = compute_mizan_metrics(raw.get("mizan", []))
    banka_metrics = compute_banka_metrics(raw.get("banka", []))
    edefter_metrics = compute_edefter_metrics(raw.get("edefter", []))
    consistency_metrics = compute_consistency_metrics(beyan_metrics, thk_metrics, banka_metrics)

    metrics = {
        "beyanname": beyan_metrics,
        "tahakkuk": thk_metrics,
        "mizan": mizan_metrics,
        "banka": banka_metrics,
        "edefter": edefter_metrics,
        "consistency": consistency_metrics,
    }

    scores = compute_scores(metrics)
    ai = build_ai_layer(smmm_id=smmm_id, client_id=client_id, period=period, metrics=metrics, scores=scores)

    return {
        "metrics": metrics,
        "scores": asdict(scores),
        "ai": ai,
    }
