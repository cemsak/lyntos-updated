from __future__ import annotations

from typing import Any
from pathlib import Path
import json


_ALIASES_CACHE: dict[str, str] | None = None


def _load_account_aliases() -> dict[str, str]:
    """
    Optional manual mapping file:
      risk_model/account_aliases.json
    Format: { "102.504": "HALKBANK ...", ... }
    """
    global _ALIASES_CACHE
    if _ALIASES_CACHE is not None:
        return _ALIASES_CACHE

    p = Path(__file__).with_name("account_aliases.json")
    if not p.exists():
        _ALIASES_CACHE = {}
        return _ALIASES_CACHE

    try:
        data = json.loads(p.read_text(encoding="utf-8"))
        if isinstance(data, dict):
            out: dict[str, str] = {}
            for k, v in data.items():
                if k is None or v is None:
                    continue
                ks = str(k).strip()
                vs = str(v).strip()
                if ks and vs:
                    out[ks] = vs
            _ALIASES_CACHE = out
            return _ALIASES_CACHE
    except Exception:
        pass

    _ALIASES_CACHE = {}
    return _ALIASES_CACHE


def _lookup_account_name(metrics: dict | None, account_code: str) -> str | None:
    """
    Priority:
      1) account_aliases.json (manual)
      2) metrics['mizan']['account_name_map'] / ['account_names'] (from compute_mizan_metrics patch)
      3) best-effort search in other mizan maps if present
    """
    aliases = _load_account_aliases()
    v = aliases.get(account_code)
    if isinstance(v, str) and v.strip():
        return v.strip()

    if not metrics or not isinstance(metrics, dict):
        return None

    mizan = metrics.get("mizan")
    if not isinstance(mizan, dict):
        return None

    # Direct maps expected after patch
    for map_key in ("account_name_map", "account_names"):
        mp = mizan.get(map_key)
        if isinstance(mp, dict):
            vv = mp.get(account_code)
            if isinstance(vv, str) and vv.strip():
                return vv.strip()

    # Fallback known keys
    for k in (
        "account_titles", "hesap_adlari", "hesap_adi_map",
        "accounts_by_code", "account_map", "hesap_map"
    ):
        mp = mizan.get(k)
        if isinstance(mp, dict):
            vv = mp.get(account_code)
            if isinstance(vv, str) and vv.strip():
                return vv.strip()
            if isinstance(vv, dict):
                for kk in ("name", "title", "hesap_adi", "account_name"):
                    vvv = vv.get(kk)
                    if isinstance(vvv, str) and vvv.strip():
                        return vvv.strip()

    return None


def _extract_kdv_matrah_by_month(metrics: dict | None) -> dict[str, float] | None:
    """
    Extract KDV matrah by month from metrics['beyanname'].
    Expected shape:
      beyanname.per_type.KDV.per_period['YYYY-MM'].matrah_toplami
    """
    if not metrics or not isinstance(metrics, dict):
        return None

    b = metrics.get("beyanname")
    if not isinstance(b, dict):
        return None

    per_type = b.get("per_type")
    if not isinstance(per_type, dict):
        return None

    kdv = per_type.get("KDV")
    if not isinstance(kdv, dict):
        return None

    per_period = kdv.get("per_period")
    if not isinstance(per_period, dict):
        return None

    out: dict[str, float] = {}
    for ym, rec in per_period.items():
        if not isinstance(rec, dict):
            continue
        if "matrah_toplami" in rec:
            try:
                out[str(ym)] = float(rec["matrah_toplami"] or 0.0)
            except Exception:
                continue

    return out or None


def _fmt_try(x: Any) -> Any:
    try:
        return float(x)
    except Exception:
        return x


def _enrich_r401a(risk: dict, metrics: dict | None, period: str | None) -> None:
    risk.setdefault("title", "Mizan 102 Alt Hesap Var, Banka Ekstresi Yok")

    vf = risk.get("value_found") or {}
    if isinstance(vf, dict):
        missing = vf.get("missing_102")
        if isinstance(missing, dict):
            details: list[dict[str, Any]] = []
            for acc, amt in missing.items():
                acc_s = str(acc)
                name = _lookup_account_name(metrics, acc_s)
                details.append({"account_code": acc_s, "account_name": name, "amount": _fmt_try(amt)})
            details.sort(key=lambda x: x.get("account_code") or "")
            vf.setdefault("missing_102_details", details)
            risk["value_found"] = vf

    risk.setdefault(
        "smmm_actions",
        [
            "Eksik görünen 102.xx hesabın bankadaki karşılığını (IBAN/hesap no) doğrulayın.",
            "2025-Q2 (Nisan–Haziran) dönemine ait tüm ekstre dosyalarının sisteme yüklendiğini kontrol edin.",
            "Hesap vadeli/bloke/POS/teminat vb. bir ürünse, hareketlerin farklı raporlarda tutulup tutulmadığını teyit edin (POS raporu, bloke hesap ekstresi, sanal POS).",
            "Mizan kaydı doğruysa bankadan ilgili döneme ait resmi ekstreyi temin edip sisteme ekleyin ve modeli yeniden çalıştırın.",
        ],
    )

    risk.setdefault(
        "checklist",
        [
            "2025-Q2 için banka klasöründe ilgili bankaya ait tüm CSV/XLSX ekstreler var mı?",
            "Aynı bankada birden fazla hesap/IBAN var mı (alt hesaplar farklı IBAN’lara bağlı olabilir)?",
            "Tarih parse/format nedeniyle satırlar ‘dönem dışı’ kalmış olabilir mi (özellikle gün/ay yer değişimi)?",
            "102.xx alt hesap adı POS/bloke/vadeli gibi ürünleri işaret ediyor mu?",
            "Eksik ekstre eklendikten sonra: yeniden çalıştır ve R-401A’nın kaybolduğunu doğrula.",
        ],
    )

    ed = risk.setdefault("evidence_details", {})
    if isinstance(ed, dict):
        ed.setdefault("period", period)
        ed.setdefault("rule_logic", "Mizan 102.xx var AND bankada ilgili dönemde hesap hareketi yok → missing_102")
        ed.setdefault(
            "note",
            "Bu durum tek başına 'usulsüzlük' değildir. 102.xx alt hesabın hangi banka/hesap olduğuna göre ekstre yüklenmeli veya alt hesap sınıflaması gözden geçirilmeli.",
        )


def _enrich_r501(risk: dict, metrics: dict | None, period: str | None) -> None:
    """
    VDK-grade enrichment for R-501:
    - Adds month breakdown for KDV matrah
    - Adds reconciliation narrative + exception framework
    - Keeps detection logic intact (numbers already computed by rule engine)
    """
    risk.setdefault("title", "KDV Matrahı - Satışlar Uyumsuzluğu")

    vf = risk.get("value_found") or {}
    if not isinstance(vf, dict):
        vf = {}

    kdv_total = _fmt_try(vf.get("kdv_matrah_sum"))
    sales_total = _fmt_try(vf.get("mizan_sales"))
    diff = _fmt_try(vf.get("diff"))
    ratio = _fmt_try(vf.get("diff_ratio"))
    ratio_pct = _fmt_try(vf.get("diff_ratio_pct"))

    # Month breakdown from beyanname
    kdv_by_month = _extract_kdv_matrah_by_month(metrics)
    kdv_month_sum = None
    kdv_sum_delta = None
    if kdv_by_month:
        kdv_month_sum = float(sum(kdv_by_month.values()))
        try:
            kdv_sum_delta = float(kdv_total) - kdv_month_sum
        except Exception:
            kdv_sum_delta = None

    # Human-readable explanation
    explanation_lines = []
    if isinstance(kdv_total, (int, float)) and isinstance(sales_total, (int, float)) and isinstance(diff, (int, float)):
        explanation_lines.append(
            f"KDV matrah toplamı = {kdv_total:,.2f} TL; Brüt satışlar (600/601/602) = {sales_total:,.2f} TL; Sapma = {diff:,.2f} TL."
        )
    if isinstance(ratio_pct, (int, float)):
        explanation_lines.append(f"Sapma oranı ≈ {ratio_pct:.2f}% (motor diff_ratio_pct).")

    if kdv_by_month:
        parts = []
        for ym in sorted(kdv_by_month.keys()):
            parts.append(f"{ym}: {kdv_by_month[ym]:,.2f} TL")
        explanation_lines.append("KDV matrah ay kırılımı: " + " | ".join(parts) + ".")
        if isinstance(kdv_month_sum, (int, float)):
            explanation_lines.append(f"Ay toplamı kontrolü: {kdv_month_sum:,.2f} TL (toplam delta: {kdv_sum_delta:,.6f} TL).")

    # Exception framework: what typically explains matrah↔sales gaps
    exception_framework = {
        "included_sales_accounts": ["600", "601", "602"],
        "adjustment_accounts_to_review": ["610", "611", "612"],  # iskontolar/iade
        "other_possible_drivers": ["İstisna satışlar", "Tevkifat", "Dönem kayması", "İade/iskonto muhasebeleştirme", "Kur/Vade/Fiyat farkı"],
        "fx_interest_accounts_to_review": ["646", "656"],
        "notes": [
            "Bu risk 'otomatik mutabakat sinyali'dir; kesin hüküm değildir.",
            "Matrah ile 600/601/602 farkı, satışların istisna/tevkifat kırılımı veya iadelerin 610/611/612’de doğru izlenmemesiyle büyüyebilir.",
        ],
    }

    # Evidence_details (VDK-grade)
    ed = risk.setdefault("evidence_details", {})

    # --- R501_AUDIT_PACK_V1 ---
    # VDK pratik: R-501 bir 'mutabakat sinyali'dir; severity, sapmanın büyüklüğüne göre kademeli olmalı.
    # Politika:
    #   rel <= 0.02  -> NO-RISK (enrich seviyesi, risk kalabilir ama severity LOW'a çekilir)
    #   0.02-0.05    -> MEDIUM
    #   0.05-0.10    -> MEDIUM
    #   > 0.10       -> HIGH
    try:
        vf = risk.get("value_found") or {}
        rel = float(vf.get("diff_ratio") or 0.0)
        rel_pct = float(vf.get("diff_ratio_pct") or (rel * 100.0))
        # severity önerisi
        if rel <= 0.02:
            sev2 = "LOW"
        elif rel <= 0.10:
            sev2 = "MEDIUM"
        else:
            sev2 = "HIGH"
        risk["severity"] = sev2
        ed.setdefault("severity_policy_applied", {
            "policy": "rel<=2% LOW; 2-10% MEDIUM; >10% HIGH",
            "rel": rel,
            "rel_pct": rel_pct,
            "result_severity": sev2,
            "note": "Bu sınıflama, VDK/Maliye pratiğinde mutabakat sapmalarının kademeli ele alınmasına göre önerilmiştir."
        })

        # Audit pack: en kötü ayı seç (KDV matrah - e-defter net satış)
        edef = (metrics or {}).get("edefter") if isinstance(metrics, dict) else {}
        se = (edef.get("sales_evidence") or {}) if isinstance(edef, dict) else {}
        kdv_by = ed.get("kdv_matrah_by_month") if isinstance(ed, dict) else None

        # --- R501_KDV_BY_MONTH_RESTORE_V1 ---

        # Bazı akışlarda R-501 evidence_details içinde kdv_matrah_by_month gelmeyebilir.

        # Bu durumda beyanname metriklerinden (KDV per_period) ay ay matrahı yeniden üret.

        if (not isinstance(kdv_by, dict)) or (kdv_by is None):

            try:

                be = (metrics or {}).get("beyanname") if isinstance(metrics, dict) else {}

                pp = (((be.get("per_type") or {}).get("KDV") or {}).get("per_period") or {}) if isinstance(be, dict) else {}

                # referans aylar: e-defter net satış ayları (varsa), yoksa beyanname per_period ayları

                ref_months = []

                if isinstance(net_by, dict) and net_by:

                    ref_months = sorted(net_by.keys())

                else:

                    ref_months = sorted(pp.keys()) if isinstance(pp, dict) else []

                kdv_by = {}

                for mm in ref_months:

                    row = (pp.get(mm) or {}) if isinstance(pp, dict) else {}

                    mt = row.get("matrah_toplami")

                    if mt is None:

                        continue

                    kdv_by[mm] = float(mt or 0.0)

                if kdv_by:

                    ed["kdv_matrah_by_month"] = kdv_by

                    # toplam kontrolü

                    sum_months = float(sum(kdv_by.values()))

                    vf = risk.get("value_found") or {}

                    kdv_sum = float(vf.get("kdv_matrah_sum") or 0.0)

                    ed["kdv_matrah_sum_check"] = {

                        "sum_of_months": sum_months,

                        "delta_vs_kdv_matrah_sum": float(sum_months - kdv_sum),

                        "note": "kdv_matrah_by_month beyanname per_period matrah_toplami üzerinden yeniden üretildi."

                    }

            except Exception as _e2:

                ew2 = ed.setdefault("enrich_warnings", [])

                if isinstance(ew2, list):

                    ew2.append(f"r501 kdv_by_month restore failed: {_e2}")
        net_by = se.get("per_month_net_sales") if isinstance(se, dict) else None
        sales_by = se.get("per_month_sales_600_601_602") if isinstance(se, dict) else None
        disc_by = se.get("per_month_discounts_610_611_612") if isinstance(se, dict) else None

        if isinstance(kdv_by, dict) and isinstance(net_by, dict):
            months = sorted(set(kdv_by.keys()) | set(net_by.keys()))
            worst_m = None
            worst_abs = -1.0
            month_rows = []
            for m in months:
                kdv = float(kdv_by.get(m) or 0.0)
                net = float(net_by.get(m) or 0.0)
                delta = net - kdv
                row = {
                    "month": m,
                    "kdv_matrah": kdv,
                    "edefter_net_sales": net,
                    "delta_net_minus_kdv": delta,
                }
                month_rows.append(row)
                if abs(delta) > worst_abs:
                    worst_abs = abs(delta)
                    worst_m = m

            pack = {
                "period": ed.get("period") if isinstance(ed, dict) else None,
                "date_range": edef.get("date_range") if isinstance(edef, dict) else None,
                "worst_month": worst_m,
                "month_table": month_rows,
                "note": "Bu paket, inceleme/savunma için ay bazında kopuşun hangi ayda yoğunlaştığını gösterir. Kesin hüküm değildir; delil seçimi için yön verir.",
            }

            if worst_m:
                pack["worst_month_details"] = {
                    "kdv_matrah": float(kdv_by.get(worst_m) or 0.0),
                    "edefter_sales_600_601_602": float((sales_by or {}).get(worst_m) or 0.0),
                    "edefter_discounts_610_611_612": float((disc_by or {}).get(worst_m) or 0.0),
                    "edefter_net_sales": float((net_by or {}).get(worst_m) or 0.0),
                }
                pack["worst_month_details"]["delta_net_minus_kdv"] = (
                    pack["worst_month_details"]["edefter_net_sales"] - pack["worst_month_details"]["kdv_matrah"]
                )

            ed.setdefault("audit_pack", pack)
    except Exception as _e:
        ew = ed.setdefault("enrich_warnings", [])
        if isinstance(ew, list):
            ew.append(f"r501 audit_pack/severity enrich failed: {_e}")

    # --- VDK-grade delil: e-Defter satış kırılımı (varsa) ---
    try:
        if isinstance(metrics, dict):
            edef = metrics.get("edefter") or {}
            se = (edef.get("sales_evidence") or {}) if isinstance(edef, dict) else {}
            if isinstance(se, dict) and se:
                ed.setdefault("edefter_sales_evidence", {
                    "date_range": edef.get("date_range"),
                    "counts": edef.get("counts"),
                    "per_month_sales_600_601_602": se.get("per_month_sales_600_601_602"),
                    "per_month_discounts_610_611_612": se.get("per_month_discounts_610_611_612"),
                    "per_month_net_sales": se.get("per_month_net_sales"),
                    "totals": se.get("totals"),
                })

                # mizan satış toplamı ↔ e-defter satış toplamı (coverage cross-check)
                vf = (risk.get("value_found") or {}) if isinstance(risk.get("value_found"), dict) else {}
                mizan_sales = float(vf.get("mizan_sales") or 0.0)
                totals = se.get("totals") or {}
                edefter_sales = float(totals.get("sales_sum") or 0.0)
                delta = abs(mizan_sales - edefter_sales)

                cc = ed.setdefault("cross_checks", {})
                if isinstance(cc, dict):
                    cc.setdefault("mizan_vs_edefter_sales_600_601_602", {
                        "mizan_sales_total": mizan_sales,
                        "edefter_sales_total": edefter_sales,
                        "abs_delta": delta,
                        "note": "E-defter satış toplamı; kayıt kapsamı/entegrasyon ve tarih alanı doğruluğuna göre eksik/ fazla görünebilir. Bu kıyas delil amaçlıdır.",
                    })

                # Ay bazında yön gösteren kıyas: KDV matrah (ay) ↔ e-defter net satış (ay)
                kdv_by_month = ed.get("kdv_matrah_by_month")
                net_by_month = se.get("per_month_net_sales")
                if isinstance(kdv_by_month, dict) and isinstance(net_by_month, dict) and (kdv_by_month or net_by_month):
                    month_delta = {}
                    worst = None
                    months = set(kdv_by_month.keys()) | set(net_by_month.keys())
                    for m in months:
                        kdv = float(kdv_by_month.get(m) or 0.0)
                        net = float(net_by_month.get(m) or 0.0)
                        dd = (net - kdv)
                        month_delta[m] = dd
                        if (worst is None) or (abs(dd) > abs(worst[1])):
                            worst = (m, dd)

                    ed.setdefault("month_level_signals", {})
                    if isinstance(ed["month_level_signals"], dict):
                        ed["month_level_signals"].setdefault("net_sales_minus_kdv_matrah_by_month", month_delta)
                        ed["month_level_signals"].setdefault("worst_month_net_minus_kdv", {"month": (worst[0] if worst else None), "delta": (worst[1] if worst else None)})
                        ed["month_level_signals"].setdefault(
                            "note",
                            "KDV matrahı ile net satışın bire bir eşit olması beklenmez (istisna/tevkifat/iade/iskonto/dönemsellik etkileri). Bu alan yalnızca 'kopuş hangi ayda yoğun?' sinyali üretir.",
                        )
    except Exception as _e:
        ew = ed.setdefault("enrich_warnings", [])
        if isinstance(ew, list):
            ew.append(f"r501 edefter enrich failed: {_e}")
    if isinstance(ed, dict):
        ed.setdefault("period", period)
        ed.setdefault("comparison", "KDV Matrahı (beyanname) ↔ Brüt Satışlar (mizan)")
        ed.setdefault("mizan_sales_accounts", ["600", "601", "602"])
        ed.setdefault("rule_logic", "KDV matrah toplamı ≠ (600/601/602) satış toplamı → sapma analizi")
        ed.setdefault("exception_framework", exception_framework)
        if explanation_lines:
            ed.setdefault("calculation_explanation", explanation_lines)
        if kdv_by_month:
            ed.setdefault("kdv_matrah_by_month", kdv_by_month)
            ed.setdefault(
                "kdv_matrah_sum_check",
                {"sum_of_months": kdv_month_sum, "delta_vs_kdv_matrah_sum": kdv_sum_delta},
            )

        ed.setdefault(
            "vdK_reconciliation_plan",
            [
                "KDV matrahı (beyanname) ile satışların aynı dönemi temsil ettiğini doğrula (2025-04/05/06).",
                "600/601/602 toplamını 610/611/612 (iskonto/iade) ile netle (brüt → net satış etkisi).",
                "İstisna/tevkifat satışlarını beyanname kırılımlarıyla karşılaştır (matrah ile satış ayrışması).",
                "Kur/vade/fiyat farkı kayıtlarının (646/656) satış/KDV matrah etkisini kontrol et.",
                "Kopuşu tespit için ay bazında örnek delil seç: ilgili ayın 5–10 yevmiye fişi/fatura örneğini çıkar ve doğrula.",
            ],
        )

    # SMMM actions / checklist (keep existing if present, else add)
    risk.setdefault(
        "smmm_actions",
        [
            "KDV matrahının toplandığı beyan dönemlerinin doğru olduğundan emin olun (2025-Q2: 2025-04/05/06).",
            "Satış toplamını 600/601/602 yanında 610/611/612 (iskonto/iade) ve istisna/tevkifat kırılımlarıyla birlikte kontrol edin.",
            "Kur/vade/fiyat farkı gibi dönem sonu kayıtlarının KDV matrahını etkileyen şekilde yanlış sınıflanmadığını kontrol edin (646/656 vb.).",
            "Sapma büyükse: ay bazında kırılım çıkarıp kopuşun hangi ayda olduğunu tespit edin ve örnek yevmiye fişlerini delil olarak çıkarın.",
        ],
    )

    risk.setdefault(
        "checklist",
        [
            "KDV1 matrah toplamı ile 600+601+602 toplamı aynı dönem mi?",
            "İade/iskonto (610/611/612) satış toplamından düşülmesi gereken şekilde kaydedilmiş mi?",
            "İstisna/tevkifat satışları doğru sınıflanmış mı (beyanname kırılımları ile karşılaştır)?",
            "E-defter/yevmiye satış fişlerinde KDV oranı/hesap kodu tutarlı mı?",
            "Sapma devam ediyorsa: ay ay delil üret (hangi ay, hangi hesap, hangi fark).",
        ],
    )


def enrich_rules_in_metrics(metrics: dict, period: str | None = None) -> None:
    """
    Enriches metrics['rules']['risks'] in-place.
    """
    if not isinstance(metrics, dict):
        return
    rules = metrics.get("rules")
    if not isinstance(rules, dict):
        return
    risks = rules.get("risks")
    if not isinstance(risks, list):
        return

    for r in risks:
        if not isinstance(r, dict):
            continue
        code = r.get("code")
        if code == "R-401A":
            _enrich_r401a(r, metrics=metrics, period=period)
        elif code == "R-501":
            _enrich_r501(r, metrics=metrics, period=period)
