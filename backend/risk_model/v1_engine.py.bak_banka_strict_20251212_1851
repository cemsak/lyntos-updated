from __future__ import annotations

from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Dict, List, Optional

from data_engine.loader import load_all_for_client_period


Number = float  # sade okunurluk için


@dataclass
class RiskScores:
    kurgan_risk: Number
    tax_compliance: Number
    smiyb_risk: Number
    radar_risk: Number
    edefter_risk: Number
    inflation_risk: Number


def _safe_float(value: Any, default: Number = 0.0) -> Number:
    if value is None:
        return default
    try:
        return float(str(value).replace(",", "."))
    except Exception:
        return default


def _first_digit(hesap_kodu: str) -> Optional[str]:
    if not hesap_kodu:
        return None
    for ch in str(hesap_kodu):
        if ch.isdigit():
            return ch
    return None


def _clamp(value: Number, lo: Number = 0.0, hi: Number = 100.0) -> Number:
    return max(lo, min(hi, value))


# ---------------------------------------------------------------------
# 1) BEYANNAME METRİKLERİ
# ---------------------------------------------------------------------
def compute_beyanname_metrics(beyan_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Beyannameleri tür ve dönem bazında özetler.

    Çıktı:
    {
      "per_type": {
          "KDV": {
              "per_period": { "2025-04": {...}, ... },
              "summary": {...}
          },
          ...
      },
      "periods": ["2025-04", "2025-05", ...]
    }
    """
    per_type: Dict[str, Dict[str, Dict[str, Any]]] = {}
    periods: set[str] = set()

    for rec in beyan_list:
        btype = rec.get("beyan_type") or "UNKNOWN"
        period = rec.get("period")  # e.g. "2025-06"
        details = rec.get("details") or {}
        if not period:
            continue
        periods.add(period)
        per_type.setdefault(btype, {}).setdefault("per_period", {})

        if btype == "KDV":
            per_type[btype]["per_period"][period] = {
                "matrah_toplami": _safe_float(details.get("matrah_toplami")),
                "hesaplanan_kdv": _safe_float(details.get("hesaplanan_kdv")),
                "toplam_kdv": _safe_float(details.get("toplam_kdv")),
                "onceki_devreden_ind_kdv": _safe_float(details.get("onceki_devreden_ind_kdv")),
                "indirimler_toplami": _safe_float(details.get("indirimler_toplami")),
            }
        elif btype == "KDV2":
            per_type[btype]["per_period"][period] = {
                "matrah": _safe_float(details.get("matrah")),
                "tevkif_edilen_kdv": _safe_float(details.get("tevkif_edilen_kdv")),
                "odenecek_kdv": _safe_float(details.get("odenecek_kdv")),
            }
        elif btype == "MUHTASAR":
            per_type[btype]["per_period"][period] = {
                "mahsup_edilecek_toplam_vergi": _safe_float(details.get("mahsup_edilecek_toplam_vergi")),
                "tevkifata_iliskin_damga_vergisi": _safe_float(details.get("tevkifata_iliskin_damga_vergisi")),
            }
        elif btype == "GECICI_KV":
            per_type[btype]["per_period"][period] = {
                "ticari_bilanco_kari": _safe_float(details.get("ticari_bilanco_kari")),
                "ticari_bilanco_zarari": _safe_float(details.get("ticari_bilanco_zarari")),
                "gecici_vergi_matrahi": _safe_float(details.get("gecici_vergi_matrahi")),
                "hesaplanan_gecici_vergi": _safe_float(details.get("hesaplanan_gecici_vergi")),
            }
        else:
            # bilinmeyen tipleri ham detayla saklıyoruz
            per_type[btype]["per_period"][period] = {
                "raw": details
            }

    # Özetler
    for btype, data in per_type.items():
        per_period = data.get("per_period", {})
        summary: Dict[str, Number] = {}
        for pvals in per_period.values():
            for key, val in pvals.items():
                if isinstance(val, (int, float)):
                    summary[key + "_sum"] = summary.get(key + "_sum", 0.0) + float(val)
        per_type[btype]["summary"] = summary

    return {
        "per_type": per_type,
        "periods": sorted(periods),
    }


# ---------------------------------------------------------------------
# 2) TAHAKKUK METRİKLERİ
# ---------------------------------------------------------------------
def compute_tahakkuk_metrics(thk_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    per_type: Dict[str, Dict[str, Dict[str, Any]]] = {}
    periods: set[str] = set()

    for rec in thk_list:
        ttype = rec.get("tax_type") or "UNKNOWN"
        period = rec.get("period")
        if not period:
            continue
        periods.add(period)
        per_type.setdefault(ttype, {}).setdefault("per_period", {})

        main_row = rec.get("main_row") or {}
        per_type[ttype]["per_period"][period] = {
            "matrah": _safe_float(main_row.get("matrah")),
            "tahakkuk_eden": _safe_float(main_row.get("tahakkuk_eden")),
            "mahsup_edilen": _safe_float(main_row.get("mahsup_edilen")),
            "odenecek_olan": _safe_float(main_row.get("odenecek_olan")),
            "total_payable": _safe_float(rec.get("total_payable")),
            "acceptance_date": rec.get("acceptance_date"),
            "issue_date": rec.get("issue_date"),
            "vade": (main_row.get("vade") or ""),
        }

    # özetler
    for ttype, data in per_type.items():
        per_period = data.get("per_period", {})
        summary: Dict[str, Number] = {}
        for pvals in per_period.values():
            for key, val in pvals.items():
                if isinstance(val, (int, float)):
                    summary[key + "_sum"] = summary.get(key + "_sum", 0.0) + float(val)
        per_type[ttype]["summary"] = summary

    return {
        "per_type": per_type,
        "periods": sorted(periods),
    }


# ---------------------------------------------------------------------
# 3) MİZAN METRİKLERİ (yapısal / radar için)
# ---------------------------------------------------------------------
def compute_mizan_metrics(mizan_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Mizan satırlarından ana sınıf bazlı özetler üretir.
    """
    class_sums: Dict[str, Dict[str, Number]] = {}
    kdv_accounts: Dict[str, Number] = {}
    equity_total = 0.0

    for row in mizan_list:
        code = str(row.get("hesap_kodu") or "")
        first = _first_digit(code)
        bakiye_borc = _safe_float(row.get("bakiye_borc"))
        bakiye_alacak = _safe_float(row.get("bakiye_alacak"))
        net = bakiye_borc - bakiye_alacak

        if first:
            cs = class_sums.setdefault(first, {"bakiye_borc": 0.0, "bakiye_alacak": 0.0, "net": 0.0})
            cs["bakiye_borc"] += bakiye_borc
            cs["bakiye_alacak"] += bakiye_alacak
            cs["net"] += net

        # KDV ilişkili hesaplar
        if code.startswith("191") or code.startswith("190") or code.startswith("360"):
            kdv_accounts[code] = kdv_accounts.get(code, 0.0) + net

        # Özkaynak sınıfı (5xx)
        if code.startswith("5"):
            equity_total += net

    assets_net = class_sums.get("1", {}).get("net", 0.0) + class_sums.get("2", {}).get("net", 0.0)
    liab_net = (
        class_sums.get("3", {}).get("net", 0.0)
        + class_sums.get("4", {}).get("net", 0.0)
        + class_sums.get("5", {}).get("net", 0.0)
    )

    # Basit likidite göstergeleri
    cash_bank = 0.0
    receivables = 0.0
    inventory = 0.0
    short_term_liab = 0.0

    for row in mizan_list:
        code = str(row.get("hesap_kodu") or "")
        net = _safe_float(row.get("bakiye_borc")) - _safe_float(row.get("bakiye_alacak"))

        if code.startswith(("10", "100", "101", "102")):
            cash_bank += net
        if code.startswith(("12", "120", "121")):
            receivables += net
        if code.startswith(("15", "150", "153")):
            inventory += net
        if code.startswith(("30", "300", "320", "321", "329", "33", "331", "332", "333", "336")):
            short_term_liab += abs(net)

    total_current_assets = cash_bank + receivables + inventory

    return {
        "class_sums": class_sums,
        "assets_net": assets_net,
        "liabilities_equity_net": liab_net,
        "equity_total": equity_total,
        "cash_bank": cash_bank,
        "receivables": receivables,
        "inventory": inventory,
        "short_term_liabilities": short_term_liab,
        "total_current_assets": total_current_assets,
        "kdv_accounts": kdv_accounts,
    }


# ---------------------------------------------------------------------
# 4) BANKA METRİKLERİ
# ---------------------------------------------------------------------
def compute_banka_metrics(banka_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    total_borc = 0.0
    total_alacak = 0.0
    pos_inflows = 0.0
    bank_fees = 0.0

    # Ayrıştırılmış kamu ödemeleri
    tax_payments_gib = 0.0
    sgk_payments = 0.0
    other_public_payments = 0.0

    tax_hits = 0
    sgk_hits = 0
    other_public_hits = 0

    # Denetlenebilir örnekler (ilk 5 satır)
    tax_samples: List[Dict[str, Any]] = []
    sgk_samples: List[Dict[str, Any]] = []
    other_public_samples: List[Dict[str, Any]] = []

    tax_tokens = [
        "GIB", "GİB",
        "VERGI", "VERGİ",
        "VERGI DAIRESI", "VERGİ DAİRESİ",
        "MALMUD", "DEFTERDARLIK",
        "TAHSILAT",
        "V.D", "VD "
    ]
    sgk_tokens = [
        "SGK", "SOSYAL GUVENLIK", "SOSYAL GÜVENLİK", "S.G.K"
    ]
    public_tokens = [
        "BELED", "TAPU", "NOTER", "TRAFIK", "TRAFİK",
        "HARÇ", "HARCL", "PASAPORT", "NÜFUS", "NUFUS",
        "GUMRUK", "GÜMRÜK", "ICRA", "İCRA", "MAHKEME"
    ]

    def _push_sample(bucket: List[Dict[str, Any]], row: Dict[str, Any], amount: float) -> None:
        if len(bucket) >= 5:
            return
        bucket.append({
            "tarih": row.get("tarih") or row.get("date") or row.get("tarih_saat"),
            "aciklama": (row.get("aciklama") or "")[:120],
            "tutar": amount,
        })

    for row in banka_list:
        borc = _safe_float(row.get("borc"))
        alacak = _safe_float(row.get("alacak"))
        desc = (row.get("aciklama") or "").upper()

        total_borc += borc
        total_alacak += alacak

        # POS ve satış tahmini (bankaya giren POS tutarları)
        if "POS" in desc or "PESINSATIS" in desc or "PEŞİNSATIŞ" in desc or "TAKSİTSATIŞ" in desc:
            pos_inflows += alacak

        # Banka ücret/komisyon tahmini
        if "ÜYE İŞYERİ ÜCRETİ" in desc or "KOMİSYON" in desc or "BESMV" in desc or "BSMV" in desc or "MASRAF" in desc:
            bank_fees += borc

        # Kamu ödemeleri sınıflandırma (borç tarafı)
        if any(tok in desc for tok in sgk_tokens):
            sgk_payments += borc
            sgk_hits += 1
            _push_sample(sgk_samples, row, borc)
        elif any(tok in desc for tok in tax_tokens):
            tax_payments_gib += borc
            tax_hits += 1
            _push_sample(tax_samples, row, borc)
        elif any(tok in desc for tok in public_tokens):
            other_public_payments += borc
            other_public_hits += 1
            _push_sample(other_public_samples, row, borc)

    # Geriye dönük uyumluluk: eski alan tax_payments = GİB/VD sınıfı
    tax_payments = tax_payments_gib

    return {
        "total_borc": total_borc,
        "total_alacak": total_alacak,
        "net_change": total_alacak - total_borc,
        "pos_inflows": pos_inflows,
        "bank_fees": bank_fees,

        "tax_payments": tax_payments,
        "tax_payments_gib": tax_payments_gib,
        "sgk_payments": sgk_payments,
        "other_public_payments": other_public_payments,

        "tax_hits": tax_hits,
        "sgk_hits": sgk_hits,
        "other_public_hits": other_public_hits,

        "tax_samples": tax_samples,
        "sgk_samples": sgk_samples,
        "other_public_samples": other_public_samples,
    }


# ---------------------------------------------------------------------
# 5) E-DEFTER METRİKLERİ
# ---------------------------------------------------------------------
def compute_edefter_metrics(edefter_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    total_lines = len(edefter_list)
    kdv_lines = 0
    fx_lines = 0
    inflation_lines = 0

    for row in edefter_list:
        code = str(row.get("hesap_kodu") or "")
        name = (row.get("hesap_adi") or "").upper()
        aciklama = (row.get("aciklama") or "").upper()
        detay = (row.get("detay") or "").upper()

        text = name + " " + aciklama + " " + detay

        if code.startswith(("190", "191", "360")) or "KDV" in text:
            kdv_lines += 1

        if any(token in text for token in ["USD", "EUR", "DOLAR", "EURO", "STERLIN"]):
            fx_lines += 1

        if "ENFLASYON" in text or "DÜZELTME" in text or "ENF.DÜZ" in text:
            inflation_lines += 1

    return {
        "total_lines": total_lines,
        "kdv_lines": kdv_lines,
        "fx_lines": fx_lines,
        "inflation_lines": inflation_lines,
        "kdv_line_ratio": (kdv_lines / total_lines) if total_lines else 0.0,
    }


# ---------------------------------------------------------------------
# 6) TUTARLILIK / UYUM METRİKLERİ (Beyan + Tahakkuk + Banka)
# ---------------------------------------------------------------------
def compute_consistency_metrics(
    beyan_metrics: Dict[str, Any],
    thk_metrics: Dict[str, Any],
    banka_metrics: Dict[str, Any],
) -> Dict[str, Any]:
    """
    Beyanname vs tahakkuk vs banka rakamsal farklarını hesaplar.
    Hukuki değerlendirme yapmaz, sadece sayı bazlı gap üretir.
    """
    per_type_b = beyan_metrics.get("per_type", {})
    per_type_t = thk_metrics.get("per_type", {})

    mismatch_total = 0.0
    mismatch_max = 0.0
    mismatch_over_100 = 0
    missing_beyan = 0
    missing_thk = 0

    # MUHTASAR şimdilik mismatch'e dahil değil (beyan tarafında sadece damga var)
    for code in ["KDV", "KDV2", "GECICI_KV"]:
        b_data = per_type_b.get(code, {})
        t_data = per_type_t.get(code, {})
        b_pp = b_data.get("per_period", {})
        t_pp = t_data.get("per_period", {})

        all_periods = set(b_pp.keys()) | set(t_pp.keys())
        for period in all_periods:
            b_val = 0.0
            t_val = 0.0

            # Beyan tarafı
            if period in b_pp:
                b = b_pp[period]
                if code == "KDV":
                    b_val = _safe_float(b.get("toplam_kdv"))
                elif code == "KDV2":
                    b_val = _safe_float(b.get("odenecek_kdv"))
                elif code == "GECICI_KV":
                    b_val = _safe_float(b.get("hesaplanan_gecici_vergi"))
            else:
                missing_beyan += 1

            # Tahakkuk tarafı (doğru alan eşlemesi)
            if period in t_pp:
                t = t_pp[period]
                if code == "KDV":
                    t_val = _safe_float(t.get("tahakkuk_eden"))
                elif code == "KDV2":
                    t_val = _safe_float(t.get("odenecek_olan")) or _safe_float(t.get("tahakkuk_eden"))
                elif code == "GECICI_KV":
                    t_val = _safe_float(t.get("tahakkuk_eden"))
            else:
                missing_thk += 1

            diff = abs(b_val - t_val)
            mismatch_total += diff
            mismatch_max = max(mismatch_max, diff)
            if diff > 100.0:
                mismatch_over_100 += 1

    # Coverage için iki baz: bilgi amaçlı total_payable_sum, esas baz odenecek_olan_sum
    tahakkuk_total = 0.0
    tahakkuk_cash_payable_total = 0.0

    for _ttype, data in per_type_t.items():
        summary = data.get("summary", {})
        tahakkuk_total += _safe_float(summary.get("total_payable_sum"))
        tahakkuk_cash_payable_total += _safe_float(summary.get("odenecek_olan_sum"))

    coverage_rate = None
    tax_payments = _safe_float(banka_metrics.get("tax_payments"))
    if tahakkuk_cash_payable_total > 0:
        coverage_rate = tax_payments / tahakkuk_cash_payable_total

    return {
        "beyan_tahakkuk_mismatch_total": mismatch_total,
        "beyan_tahakkuk_mismatch_max": mismatch_max,
        "beyan_tahakkuk_mismatch_over_100": mismatch_over_100,
        "missing_beyan_count": missing_beyan,
        "missing_tahakkuk_count": missing_thk,
        "tahakkuk_total_payable": tahakkuk_total,
        "tahakkuk_cash_payable_total": tahakkuk_cash_payable_total,
        "tax_payments_total": tax_payments,
        "tax_payment_coverage_rate": coverage_rate,
    }



# ---------------------------------------------------------------------
# 7) SKORLAR
# ---------------------------------------------------------------------
def compute_scores(metrics: Dict[str, Any]) -> RiskScores:
    beyan = metrics.get("beyanname", {})
    mizan = metrics.get("mizan", {})
    banka = metrics.get("banka", {})
    edefter = metrics.get("edefter", {})
    cons = metrics.get("consistency", {})

    # --- Vergi uyum skoru (100 = iyi uyum, 0 = kötü uyum) ---
    tax_compliance = 100.0

    mismatch_total = _safe_float(cons.get("beyan_tahakkuk_mismatch_total"))
    mismatch_over_100 = int(cons.get("beyan_tahakkuk_mismatch_over_100") or 0)
    missing_forms = int(cons.get("missing_beyan_count") or 0) + int(cons.get("missing_tahakkuk_count") or 0)  # noqa
    coverage_rate = cons.get("tax_payment_coverage_rate")

    # Beyan–tahakkuk tutarlılığı: fark büyüdükçe uyum düşer
    tax_compliance -= min(40.0, mismatch_total / 1000.0 * 5.0)
    tax_compliance -= mismatch_over_100 * 5.0
    tax_compliance -= missing_forms * 10.0

    # Ödeme kapsamı: sadece "eksik ödeme" sinyalinde düşür.
    # coverage_rate > 1 çoğu zaman dönem kayması / sınıflandırma genişliği nedeniyle olabilir.
    if coverage_rate is not None and coverage_rate < 0.95:
        tax_compliance -= 20.0

    tax_compliance = _clamp(tax_compliance)

    # KURGAN harmanı risk üzerinden yapılır (0 iyi, 100 kötü)
    tax_risk = 100.0 - tax_compliance

    # --- E-defter skoru ---
    total_lines = int(edefter.get("total_lines") or 0)
    kdv_ratio = _safe_float(edefter.get("kdv_line_ratio"))
    fx_lines = int(edefter.get("fx_lines") or 0)
    inflation_lines = int(edefter.get("inflation_lines") or 0)

    if total_lines == 0:
        edefter_score = 90.0  # veri yok → yüksek risk
    else:
        edefter_score = 30.0
        if kdv_ratio < 0.02:
            edefter_score += 20.0  # KDV ile ilgili satır oranı çok düşük
        if fx_lines > 0 and inflation_lines == 0:
            edefter_score += 20.0  # döviz var ama enflasyon/düzeltme izi yok
        if total_lines > 20000:
            edefter_score += 10.0  # çok büyük yevmiye → karmaşıklık

    edefter_score = _clamp(edefter_score)

    # --- SMİYB riski (sadece sayısal pattern) ---
    b_kdv = beyan.get("per_type", {}).get("KDV", {}).get("summary", {})
    b_kdv2 = beyan.get("per_type", {}).get("KDV2", {}).get("summary", {})
    kdv_matrah = _safe_float(b_kdv.get("matrah_toplami_sum"))
    kdv2_matrah = _safe_float(b_kdv2.get("matrah_sum"))
    pos_inflows = _safe_float(banka.get("pos_inflows"))
    receivables = _safe_float(mizan.get("receivables"))

    smiyb_score = 25.0
    if kdv_matrah > 0:
        ratio_kdv2 = kdv2_matrah / kdv_matrah
        if ratio_kdv2 > 0.1:
            smiyb_score += min(30.0, (ratio_kdv2 - 0.1) * 100.0)  # 0.4+ seviyede ekstra puan

    approx_turnover = kdv_matrah
    if approx_turnover > 0 and pos_inflows > approx_turnover * 1.2:
        smiyb_score += 20.0  # POS cirosu beyana göre çok yüksek

    if receivables > approx_turnover * 1.5:
        smiyb_score += 10.0  # alacaklar satışa göre çok yüksek

    smiyb_score = _clamp(smiyb_score)

    # --- Radar / yapısal risk ---
    total_current_assets = _safe_float(mizan.get("total_current_assets"))
    short_term_liab = _safe_float(mizan.get("short_term_liabilities"))
    equity_total = _safe_float(mizan.get("equity_total"))

    radar_score = 30.0
    if total_current_assets and short_term_liab:
        current_ratio = total_current_assets / short_term_liab
        if current_ratio < 1.0:
            radar_score += 25.0
        elif current_ratio < 1.2:
            radar_score += 15.0
        elif current_ratio < 1.5:
            radar_score += 5.0

    if equity_total <= 0:
        radar_score += 20.0  # negatif veya çok düşük özkaynak

    radar_score = _clamp(radar_score)

    # --- Enflasyon / kur risk skoru (kabaca, hukuki görüş değil) ---
    fx_lines = int(edefter.get("fx_lines") or 0)
    inflation_lines = int(edefter.get("inflation_lines") or 0)
    fx_exposed = fx_lines > 0

    inflation_score = 30.0
    if fx_exposed and inflation_lines == 0:
        inflation_score += 30.0  # döviz var, düzeltme izi yok
    elif fx_exposed and inflation_lines > 0:
        inflation_score += 10.0
    else:
        inflation_score += 5.0  # döviz yok → yine de genel enflasyon kontrolü gerekir

    inflation_score = _clamp(inflation_score)

    # --- Genel KURGAN skoru (blend) ---
    kurgan = (
        tax_risk * 0.3
        + smiyb_score * 0.25
        + radar_score * 0.2
        + edefter_score * 0.15
        + inflation_score * 0.1
    )

    kurgan = _clamp(kurgan)

    return RiskScores(
        kurgan_risk=kurgan,
        tax_compliance=tax_compliance,
        smiyb_risk=smiyb_score,
        radar_risk=radar_score,
        edefter_risk=edefter_score,
        inflation_risk=inflation_score,
    )


# ---------------------------------------------------------------------
# 8) KURAL TABANLI AI METİN KATI
# ---------------------------------------------------------------------
def build_ai_layer(
    smmm_id: str,
    client_id: str,
    period: str,
    metrics: Dict[str, Any],
    scores: RiskScores,
) -> Dict[str, Any]:
    """
    Dış LLM çağrısı yapmadan kural tabanlı Türkçe özet üretir.
    Hukuki sonuç cümlesi üretmez, sadece SMMM için checklist / tavsiye üretir.
    """
    cons = metrics.get("consistency", {})
    mizan = metrics.get("mizan", {})
    edefter = metrics.get("edefter", {})

    def fmt_pct(x: Optional[Number]) -> str:
        if x is None:
            return "-"
        return f"{x*100:.1f}%"

    coverage_rate = cons.get("tax_payment_coverage_rate")
    coverage_txt = fmt_pct(coverage_rate) if coverage_rate is not None else "-"

    summary_lines: List[str] = []

    summary_lines.append(
        f"{client_id} için {period} dönemi verileri (beyanname, tahakkuk, mizan, banka, e-defter) birlikte analiz edildi."
    )
    summary_lines.append(
        f"Kurgan toplam risk skoru: {scores.kurgan_risk:.1f} / 100 "
        f"(Vergi uyumu: {scores.tax_compliance:.1f}, SMİYB: {scores.smiyb_risk:.1f}, "
        f"Yapısal radar: {scores.radar_risk:.1f}, E-defter: {scores.edefter_risk:.1f}, Enflasyon: {scores.inflation_risk:.1f})."
    )
    if coverage_rate is not None:
        summary_lines.append(
            f"Tahakkuk eden vergilerin banka hareketleri üzerinden ödeme kapsam oranı yaklaşık {coverage_txt} seviyesinde."
        )

    # Checklist
    checklist: List[str] = []
    if _safe_float(cons.get("beyan_tahakkuk_mismatch_total")) > 0:
        checklist.append(
            "Beyanname ile tahakkuk tutarları arasındaki farkları (özellikle 100 TL üzeri olanları) tek tek kontrol edin."
        )
    if coverage_rate is not None and (coverage_rate < 0.95 or coverage_rate > 1.05):
        checklist.append(
            "Banka hesap hareketlerinde vergi dairesi ödemeleri ile tahakkuk toplamlarını karşılaştırın; eksik veya fazla ödeme var mı?"
        )
    if _safe_float(mizan.get("equity_total")) <= 0:
        checklist.append(
            "Özkaynakların negatif veya çok zayıf olup olmadığını kontrol edin; sermaye tamamlama / güçlendirme ihtiyacını değerlendirin."
        )
    if int(edefter.get("fx_lines") or 0) > 0 and int(edefter.get("inflation_lines") or 0) == 0:
        checklist.append(
            "Dövizli işlemler için kur değerlemesi ve enflasyon muhasebesi kayıtlarının (varsa) doğru yapıldığını doğrulayın."
        )
    if not checklist:
        checklist.append(
            "Bu dönem için kritik bir alarm görünmüyor; yine de örnekleme yoluyla birkaç beyanname, banka hareketi ve yevmiye kaydını manuel kontrol edin."
        )

    advice_lines: List[str] = []
    advice_lines.append(
        "Bu çıktı, sayısal tutarlılık ve oran analizi yapar; hukuki nitelikte bir vergi görüşü değildir."
    )
    advice_lines.append(
        "Herhangi bir önemli fark veya yüksek risk görülen alan için, ilgili beyannameleri, tahakkuk fişlerini ve e-defter kayıtlarını resmi mevzuat çerçevesinde detaylı inceleyin."
    )
    advice_lines.append(
        "Özellikle enflasyon muhasebesi ve kur değerlemesi konularında, güncel Vergi Usul Kanunu düzenlemeleri ve Gelir İdaresi Başkanlığı özelgeleri esas alınmalıdır."
    )

    return {
        "summary": "\n".join(summary_lines),
        "checklist": "\n".join(f"- {item}" for item in checklist),
        "advice": "\n".join(advice_lines),
    }


# ---------------------------------------------------------------------
# 9) DIŞA AÇILAN ANA FONKSİYON
# ---------------------------------------------------------------------
def run_risk_model_v1(
    base_dir: str | Path,
    smmm_id: str,
    client_id: str,
    period: str,
) -> Dict[str, Any]:
    """
    FastAPI endpoint'inin çağıracağı üst seviye fonksiyon.
    """
    base_path = Path(base_dir)
    raw = load_all_for_client_period(
        base_dir=base_path,
        smmm_id=smmm_id,
        client_id=client_id,
        period=period,
    )

    beyan_metrics = compute_beyanname_metrics(raw.get("beyanname", []))
    thk_metrics = compute_tahakkuk_metrics(raw.get("tahakkuk", []))
    mizan_metrics = compute_mizan_metrics(raw.get("mizan", []))
    banka_metrics = compute_banka_metrics(raw.get("banka", []))
    edefter_metrics = compute_edefter_metrics(raw.get("edefter", []))
    consistency_metrics = compute_consistency_metrics(beyan_metrics, thk_metrics, banka_metrics)

    metrics = {
        "beyanname": beyan_metrics,
        "tahakkuk": thk_metrics,
        "mizan": mizan_metrics,
        "banka": banka_metrics,
        "edefter": edefter_metrics,
        "consistency": consistency_metrics,
    }

    scores = compute_scores(metrics)
    ai = build_ai_layer(smmm_id=smmm_id, client_id=client_id, period=period, metrics=metrics, scores=scores)

    return {
        "metrics": metrics,
        "scores": asdict(scores),
        "ai": ai,
    }
