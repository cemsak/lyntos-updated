from __future__ import annotations
import re

from datetime import date, datetime, timedelta

from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Dict, List, Optional

from data_engine.loader import load_all_for_client_period


Number = float  # sade okunurluk için


@dataclass
class RiskScores:
    kurgan_risk: Number
    tax_compliance: Number
    smiyb_risk: Number
    radar_risk: Number
    edefter_risk: Number
    inflation_risk: Number


def _safe_float(value: Any, default: Number = 0.0) -> Number:
    if value is None:
        return default
    try:
        return float(str(value).replace(",", "."))
    except Exception:
        return default


def _first_digit(hesap_kodu: str) -> Optional[str]:
    if not hesap_kodu:
        return None
    for ch in str(hesap_kodu):
        if ch.isdigit():
            return ch
    return None


def _clamp(value: Number, lo: Number = 0.0, hi: Number = 100.0) -> Number:
    return max(lo, min(hi, value))


# ---------------------------------------------------------------------
# 1) BEYANNAME METRİKLERİ
# ---------------------------------------------------------------------
def compute_beyanname_metrics(beyan_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Beyannameleri tür ve dönem bazında özetler.

    Çıktı:
    {
      "per_type": {
          "KDV": {
              "per_period": { "2025-04": {...}, ... },
              "summary": {...}
          },
          ...
      },
      "periods": ["2025-04", "2025-05", ...]
    }
    """
    per_type: Dict[str, Dict[str, Dict[str, Any]]] = {}
    periods: set[str] = set()

    for rec in beyan_list:
        btype = rec.get("beyan_type") or "UNKNOWN"
        period = rec.get("period")  # e.g. "2025-06"
        details = rec.get("details") or {}
        if not period:
            continue
        periods.add(period)
        per_type.setdefault(btype, {}).setdefault("per_period", {})

        if btype == "KDV":
            per_type[btype]["per_period"][period] = {
                "matrah_toplami": _safe_float(details.get("matrah_toplami")),
                "hesaplanan_kdv": _safe_float(details.get("hesaplanan_kdv")),
                "toplam_kdv": _safe_float(details.get("toplam_kdv")),
                "onceki_devreden_ind_kdv": _safe_float(details.get("onceki_devreden_ind_kdv")),
                "indirimler_toplami": _safe_float(details.get("indirimler_toplami")),
            }
        elif btype == "KDV2":
            per_type[btype]["per_period"][period] = {
                "matrah": _safe_float(details.get("matrah")),
                "tevkif_edilen_kdv": _safe_float(details.get("tevkif_edilen_kdv")),
                "odenecek_kdv": _safe_float(details.get("odenecek_kdv")),
            }
        elif btype == "MUHTASAR":
            per_type[btype]["per_period"][period] = {
                "mahsup_edilecek_toplam_vergi": _safe_float(details.get("mahsup_edilecek_toplam_vergi")),
                "tevkifata_iliskin_damga_vergisi": _safe_float(details.get("tevkifata_iliskin_damga_vergisi")),
            }
        elif btype == "GECICI_KV":
            per_type[btype]["per_period"][period] = {
                "ticari_bilanco_kari": _safe_float(details.get("ticari_bilanco_kari")),
                "ticari_bilanco_zarari": _safe_float(details.get("ticari_bilanco_zarari")),
                "gecici_vergi_matrahi": _safe_float(details.get("gecici_vergi_matrahi")),
                "hesaplanan_gecici_vergi": _safe_float(details.get("hesaplanan_gecici_vergi")),
            }
        else:
            # bilinmeyen tipleri ham detayla saklıyoruz
            per_type[btype]["per_period"][period] = {
                "raw": details
            }

    # Özetler
    for btype, data in per_type.items():
        per_period = data.get("per_period", {})
        summary: Dict[str, Number] = {}
        for pvals in per_period.values():
            for key, val in pvals.items():
                if isinstance(val, (int, float)):
                    summary[key + "_sum"] = summary.get(key + "_sum", 0.0) + float(val)
        per_type[btype]["summary"] = summary

    return {
        "per_type": per_type,
        "periods": sorted(periods),
    }


# ---------------------------------------------------------------------
# 2) TAHAKKUK METRİKLERİ
# ---------------------------------------------------------------------
def compute_tahakkuk_metrics(thk_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    per_type: Dict[str, Dict[str, Dict[str, Any]]] = {}
    periods: set[str] = set()

    for rec in thk_list:
        ttype = rec.get("tax_type") or "UNKNOWN"
        period = rec.get("period")
        if not period:
            continue
        periods.add(period)
        per_type.setdefault(ttype, {}).setdefault("per_period", {})

        main_row = rec.get("main_row") or {}
        per_type[ttype]["per_period"][period] = {
            "matrah": _safe_float(main_row.get("matrah")),
            "tahakkuk_eden": _safe_float(main_row.get("tahakkuk_eden")),
            "mahsup_edilen": _safe_float(main_row.get("mahsup_edilen")),
            "odenecek_olan": _safe_float(main_row.get("odenecek_olan")),
            "total_payable": _safe_float(rec.get("total_payable")),
            "acceptance_date": rec.get("acceptance_date"),
            "issue_date": rec.get("issue_date"),
            "vade": (main_row.get("vade") or ""),
            "thn": (rec.get("thn") or "").strip().upper(),
            "source_file": rec.get("source_file"),
        }

    # özetler
    for ttype, data in per_type.items():
        per_period = data.get("per_period", {})
        summary: Dict[str, Number] = {}
        for pvals in per_period.values():
            for key, val in pvals.items():
                if isinstance(val, (int, float)):
                    summary[key + "_sum"] = summary.get(key + "_sum", 0.0) + float(val)
        per_type[ttype]["summary"] = summary

    return {
        "per_type": per_type,
        "periods": sorted(periods),
    }


# ---------------------------------------------------------------------
# 3) MİZAN METRİKLERİ (yapısal / radar için)
# ---------------------------------------------------------------------
def compute_mizan_metrics(mizan_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Mizan satırlarından ana sınıf bazlı özetler üretir.
    """
    class_sums: Dict[str, Dict[str, Number]] = {}
    kdv_accounts: Dict[str, Number] = {}
    account_name_map: Dict[str, str] = {}
    equity_total = 0.0

    for row in mizan_list:
        code = str(row.get("hesap_kodu") or "")
        code = code.strip()
        name = row.get("hesap_adi") or row.get("account_name") or row.get("name")
        if isinstance(name, str) and name.strip() and code and code not in account_name_map:
            account_name_map[code] = name.strip()
        first = _first_digit(code)
        bakiye_borc = _safe_float(row.get("bakiye_borc"))
        bakiye_alacak = _safe_float(row.get("bakiye_alacak"))
        net = bakiye_borc - bakiye_alacak

        if first:
            cs = class_sums.setdefault(first, {"bakiye_borc": 0.0, "bakiye_alacak": 0.0, "net": 0.0})
            cs["bakiye_borc"] += bakiye_borc
            cs["bakiye_alacak"] += bakiye_alacak
            cs["net"] += net

        # KDV ilişkili hesaplar
        if code.startswith("191") or code.startswith("190") or code.startswith("360"):
            kdv_accounts[code] = kdv_accounts.get(code, 0.0) + net

        # Özkaynak sınıfı (5xx)
        if code.startswith("5"):
            equity_total += net

    assets_net = class_sums.get("1", {}).get("net", 0.0) + class_sums.get("2", {}).get("net", 0.0)
    liab_net = (
        class_sums.get("3", {}).get("net", 0.0)
        + class_sums.get("4", {}).get("net", 0.0)
        + class_sums.get("5", {}).get("net", 0.0)
    )

    # Basit likidite göstergeleri
    cash_bank = 0.0
    receivables = 0.0
    inventory = 0.0
    short_term_liab = 0.0

    for row in mizan_list:
        code = str(row.get("hesap_kodu") or "")
        net = _safe_float(row.get("bakiye_borc")) - _safe_float(row.get("bakiye_alacak"))

        if code.startswith(("10", "100", "101", "102")):
            cash_bank += net
        if code.startswith(("12", "120", "121")):
            receivables += net
        if code.startswith(("15", "150", "153")):
            inventory += net
        if code.startswith(("30", "300", "320", "321", "329", "33", "331", "332", "333", "336")):
            short_term_liab += abs(net)

    total_current_assets = cash_bank + receivables + inventory

    return {
        "class_sums": class_sums,
        "assets_net": assets_net,
        "liabilities_equity_net": liab_net,
        "equity_total": equity_total,
        "cash_bank": cash_bank,
        "receivables": receivables,
        "inventory": inventory,
        "short_term_liabilities": short_term_liab,
        "total_current_assets": total_current_assets,
        "kdv_accounts": kdv_accounts,
        "account_name_map": account_name_map,
    }


# ---------------------------------------------------------------------
# 4) BANKA METRİKLERİ
# ---------------------------------------------------------------------
def compute_banka_metrics(banka_list: List[Dict[str, Any]], period: Optional[str] = None) -> Dict[str, Any]:
    """
    Banka hareketlerinden (period opsiyonel):
      - tarih aralığı (bank_date_min/max)
      - satır sayısı (bank_row_count, bank_row_count_total, bank_row_count_deduped)
      - duplicate_row_count + per_account_duplicates
      - per_account_opening / closing / gap_ratio / ok (bakiye zinciri kalite analizi)
      - 'vergi/SGK ödeme' sinyalli satırlar (tax_confirmed_rows)

    Beklenen alanlar (parser'dan):
      tarih, borc, alacak, bakiye, aciklama, referans (ops.), source_file (ops.)
    """
    from datetime import datetime, date

    def parse_date(s: str):
        s = (s or "").strip()
        for fmt in ("%Y-%m-%d", "%d.%m.%Y", "%d/%m/%Y"):
            try:
                return datetime.strptime(s, fmt).date()
            except Exception:
                pass
        return None

    def period_range(p: Optional[str]):
        if not p:
            return None
        m = re.match(r"^\s*(\d{4})\s*-\s*Q([1-4])\s*$", str(p))
        if not m:
            m = re.match(r"^\s*(\d{4})\s*Q([1-4])\s*$", str(p))
        if not m:
            m = re.match(r"^\s*(\d{4})\s*-\s*([1-4])\s*$", str(p))
        if not m:
            return None
        y = int(m.group(1)); q = int(m.group(2))
        if q == 1:
            return (date(y, 1, 1), date(y, 3, 31))
        if q == 2:
            return (date(y, 4, 1), date(y, 6, 30))
        if q == 3:
            return (date(y, 7, 1), date(y, 9, 30))
        return (date(y, 10, 1), date(y, 12, 31))

    def round2(x):
        try:
            return round(float(x), 2)
        except Exception:
            return None

    def infer_acc_key(row: Dict[str, Any]) -> str:
        # Prefer explicit identifiers
        for k in ("iban", "hesap_no", "account_no", "account"):
            v = (row.get(k) or "").strip()
            if v:
                return v
        sf = (row.get("source_file") or "").strip()
        # If helper exists in module scope, use it
        try:
            return _infer_acc_key_from_source_file(sf)  # type: ignore
        except Exception:
            # fallback: strip month-ish suffixes and keep leading "102.xx BANK"
            base = sf.split("/")[-1]
            base_u = re.sub(r"\.csv$", "", base, flags=re.I)
            base_u = re.sub(r"\s+", " ", base_u).strip()
            m = re.match(r"^(\d+\.\d+)\s+([A-Za-zİIĞÜŞÖÇ]+)", base_u)
            if m:
                return f"{m.group(1)} {m.group(2)}".upper()
            return base_u.upper() if base_u else "UNKNOWN"

    # --- tax/SGK detection (existing conservative approach) ---
    thn_re = re.compile(r"(20\d{6}01M[A-Za-z0-9]{2,4}\d{7})", re.IGNORECASE)
    tax_kw = re.compile(r"\b(KDV|MUHTASAR|SGK|VERG[Iİ]|GEL[Iİ]R\s*I[Dİ]RES[Iİ]|TAHAKKUK|T[CÇ]\.?|V\.D\.|V\.D|GIB|GİB)\b", re.IGNORECASE)

    rng = period_range(period)
    lo = rng[0] if rng else None
    hi = rng[1] if rng else None

    bank_row_count_total = len(banka_list or [])
    bank_row_count = 0

    # per-account accumulator
    acct = {}  # acc_key -> dict
    duplicate_row_count = 0

    bank_min = None
    bank_max = None

    tax_confirmed_rows = []

    for row in (banka_list or []):
        if not isinstance(row, dict):
            continue

        d = parse_date(row.get("tarih") or "")
        if rng and d:
            if d < lo or d > hi:
                continue

        # In-period rows count (even if later deduped)
        bank_row_count += 1

        if d:
            bank_min = d if (bank_min is None or d < bank_min) else bank_min
            bank_max = d if (bank_max is None or d > bank_max) else bank_max

        borc = _safe_float(row.get("borc"))
        alacak = _safe_float(row.get("alacak"))
        delta = float(alacak) - float(borc)
        bakiye = _safe_float(row.get("bakiye"))

        acc_key = infer_acc_key(row)
        st = acct.get(acc_key)
        if not st:
            st = {
                "rows": [],
                "seen": set(),
                "dup": 0,
                "src": set(),
            }
            acct[acc_key] = st

        sf = (row.get("source_file") or "").strip()
        if sf:
            st["src"].add(sf)

        aciklama = (row.get("aciklama") or row.get("detay") or "").strip().upper()
        ref = (row.get("referans") or row.get("ref") or row.get("dekont_no") or row.get("fis_no") or "").strip().upper()

        # signature: same account + same date + same delta + same balance + compact ref/desc
        sig = (
            (d.isoformat() if d else None),
            round2(delta),
            round2(bakiye),
            ref[:32],
            aciklama[:64],
        )
        if sig in st["seen"]:
            st["dup"] += 1
            duplicate_row_count += 1
            continue
        st["seen"].add(sig)

        st["rows"].append((d, float(delta), float(bakiye) if bakiye is not None else None))

        # tax/sgk strong signal row capture
        if aciklama and tax_kw.search(aciklama):
            mthn = thn_re.search(aciklama)
            tax_confirmed_rows.append({
                "tarih": row.get("tarih"),
                "borc": borc,
                "alacak": alacak,
                "bakiye": bakiye,
                "aciklama": (row.get("aciklama") or ""),
                "thn": (mthn.group(1) if mthn else None),
                "source_file": sf,
                "acc_key": acc_key,
            })

    account_count = len(acct)

    # --- per-account balance chain quality ---
    per_account_opening = {}
    per_account_closing = {}
    per_account_gap_ratio = {}
    per_account_ok = {}
    per_account_sources = {}
    per_account_duplicates = {}

    opening_total = 0.0
    closing_total = 0.0
    net_change_total = 0.0

    ok_acc = 0
    used_acc = 0

    for acc_key, st in acct.items():
        rows = st["rows"]
        per_account_duplicates[acc_key] = int(st.get("dup") or 0)
        per_account_sources[acc_key] = sorted(list(st.get("src") or []))

        # rows can have None date/balance; filter for chain computations
        chain_rows = [(d, delta, bal) for (d, delta, bal) in rows if d is not None]
        if not chain_rows:
            per_account_opening[acc_key] = None
            per_account_closing[acc_key] = None
            per_account_gap_ratio[acc_key] = None
            per_account_ok[acc_key] = False
            continue

        used_acc += 1

        # net change (deduped)
        acc_net = sum(float(delta) for (_, delta, _) in chain_rows)
        net_change_total += acc_net

        # opening/closing via balance-before/after set difference (order independent)
        bal_rows = [(d, delta, bal) for (d, delta, bal) in chain_rows if bal is not None]
        if not bal_rows:
            per_account_opening[acc_key] = None
            per_account_closing[acc_key] = None
            per_account_gap_ratio[acc_key] = None
            per_account_ok[acc_key] = False
            continue

        min_d = min(d for (d, _, _) in bal_rows)
        max_d = max(d for (d, _, _) in bal_rows)

        after_vals = [round2(bal) for (_, _, bal) in bal_rows if round2(bal) is not None]
        before_vals = [round2(bal - delta) for (_, delta, bal) in bal_rows if round2(bal - delta) is not None]
        after_set = set(after_vals)
        before_set = set(before_vals)

        # opening candidates from min date
        open_cands = [round2(bal - delta) for (d, delta, bal) in bal_rows if d == min_d and round2(bal - delta) is not None]
        opening = None
        for c in open_cands:
            if c not in after_set:
                opening = c
                break
        if opening is None and open_cands:
            opening = open_cands[0]

        # closing candidates from max date
        close_cands = [round2(bal) for (d, _, bal) in bal_rows if d == max_d and round2(bal) is not None]
        closing = None
        for c in close_cands:
            if c not in before_set:
                closing = c
                break
        if closing is None and close_cands:
            closing = close_cands[-1]

        per_account_opening[acc_key] = opening
        per_account_closing[acc_key] = closing

        # gap ratio
        if opening is None or closing is None:
            per_account_gap_ratio[acc_key] = None
            per_account_ok[acc_key] = False
            continue

        close_calc = float(opening) + float(acc_net)
        gap = abs(float(closing) - close_calc)
        gap_ratio = gap / max(1.0, abs(float(closing)))
        per_account_gap_ratio[acc_key] = gap_ratio

        ok = bool(gap_ratio <= 0.02)
        per_account_ok[acc_key] = ok
        if ok:
            ok_acc += 1

        opening_total += float(opening)
        closing_total += float(closing)

    accounts_ok_ratio = (ok_acc / max(1, used_acc)) if used_acc else 0.0
    closing_balance_calculated = opening_total + net_change_total
    balance_gap_ratio = abs(closing_total - closing_balance_calculated) / max(1.0, abs(closing_total))
    balance_consistency_ok = bool((accounts_ok_ratio >= 0.80) and (balance_gap_ratio <= 0.02))

    # bank_row_count_deduped: in-period rows minus duplicates
    bank_row_count_deduped = max(0, bank_row_count - duplicate_row_count)

    return {
        "bank_date_min": bank_min.isoformat() if bank_min else None,
        "bank_date_max": bank_max.isoformat() if bank_max else None,
        "bank_row_count_total": bank_row_count_total,
        "bank_row_count": bank_row_count,
        "bank_row_count_deduped": bank_row_count_deduped,
        "duplicate_row_count": duplicate_row_count,
        "account_count": account_count,
        "accounts_ok_ratio": accounts_ok_ratio,
        "balance_consistency_ok": balance_consistency_ok,
        "opening_balance": opening_total,
        "closing_balance": closing_total,
        "net_change_total": net_change_total,
        "closing_balance_calculated": closing_balance_calculated,
        "balance_gap_ratio": balance_gap_ratio,
        "per_account_opening": per_account_opening,
        "per_account_closing": per_account_closing,
        "per_account_gap_ratio": per_account_gap_ratio,
        "per_account_ok": per_account_ok,
        "per_account_sources": per_account_sources,
        "per_account_duplicates": per_account_duplicates,
        "tax_confirmed_rows": tax_confirmed_rows,
    }

def compute_edefter_metrics(edefter_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    E-defter iç kontrol metrikleri.
    - Mevcut sinyaller (KDV/FX/Enflasyon)
    - Ay bazında satış delili: 600/601/602 (brüt) ve 610/611/612 (iade/iskonto)
    Not: Bu metrikler "delil" amaçlıdır; tek başına hüküm değildir.
    """
    import datetime as _dt

    def _safe_float(x):
        try:
            if x is None:
                return 0.0
            if isinstance(x, (int, float)):
                return float(x)
            s = str(x).strip()
            if not s:
                return 0.0
            # TR format toleransı: 3.431,68 -> 3431.68
            s = s.replace(".", "").replace(",", ".")
            return float(s)
        except Exception:
            return 0.0

    def _parse_date(v):
        if not v:
            return None
        s = str(v).strip()
        if not s:
            return None
        for fmt in ("%Y-%m-%d", "%d.%m.%Y", "%d/%m/%Y", "%Y%m%d"):
            try:
                return _dt.datetime.strptime(s, fmt).date()
            except Exception:
                pass
        return None

    total_lines = len(edefter_list or [])
    kdv_lines = 0
    fx_lines = 0
    inflation_lines = 0

    dated = 0
    undated = 0
    dmin = None
    dmax = None

    per_month_sales = {}       # 600/601/602: credit - debit
    per_month_discounts = {}   # 610/611/612: debit - credit
    per_month_net_sales = {}   # sales - discounts

    for row in (edefter_list or []):
        code = str(row.get("hesap_kodu") or row.get("account_code") or "").strip()
        name = (row.get("hesap_adi") or row.get("account_name") or "").upper()
        aciklama = (row.get("aciklama") or row.get("description") or "").upper()
        detay = (row.get("detay") or row.get("detail") or "").upper()
        text = name + " " + aciklama + " " + detay

        if code.startswith(("190", "191", "360")) or "KDV" in text:
            kdv_lines += 1
        if any(token in text for token in ["USD", "EUR", "DOLAR", "EURO", "STERLIN"]):
            fx_lines += 1
        if "ENFLASYON" in text or "DÜZELTME" in text or "ENF.DÜZ" in text:
            inflation_lines += 1

        dt = _parse_date(row.get("tarih") or row.get("date") or row.get("islem_tarihi") or row.get("yevmiye_tarihi"))
        if dt is None:
            undated += 1
            continue
        dated += 1
        dmin = dt if dmin is None else min(dmin, dt)
        dmax = dt if dmax is None else max(dmax, dt)
        month = f"{dt.year:04d}-{dt.month:02d}"

        debit = _safe_float(row.get("borc") or row.get("debit") or row.get("borc_tutar"))
        credit = _safe_float(row.get("alacak") or row.get("credit") or row.get("alacak_tutar"))

        if code.startswith(("600", "601", "602")):
            amt = (credit - debit)
            if abs(amt) > 0.0001:
                per_month_sales[month] = per_month_sales.get(month, 0.0) + amt

        if code.startswith(("610", "611", "612")):
            amt = (debit - credit)
            if abs(amt) > 0.0001:
                per_month_discounts[month] = per_month_discounts.get(month, 0.0) + amt

    for m in set(per_month_sales.keys()) | set(per_month_discounts.keys()):
        s = float(per_month_sales.get(m, 0.0) or 0.0)
        d = float(per_month_discounts.get(m, 0.0) or 0.0)
        per_month_net_sales[m] = s - d

    def _sum(d: dict) -> float:
        return float(sum((float(v or 0.0) for v in (d or {}).values()), 0.0))

    out = {
        # eski alanları koru (geriye uyumluluk)
        "total_lines": total_lines,
        "kdv_lines": kdv_lines,
        "fx_lines": fx_lines,
        "inflation_lines": inflation_lines,
        "kdv_line_ratio": (kdv_lines / total_lines) if total_lines else 0.0,

        # yeni alanlar
        "counts": {
            "dated_lines": dated,
            "undated_lines": undated,
            "dated_ratio": (dated / max(1, (dated + undated))),
        },
        "date_range": {
            "min": (str(dmin) if dmin else None),
            "max": (str(dmax) if dmax else None),
        },
        "sales_evidence": {
            "sales_accounts": ["600", "601", "602"],
            "discount_accounts": ["610", "611", "612"],
            "per_month_sales_600_601_602": per_month_sales,
            "per_month_discounts_610_611_612": per_month_discounts,
            "per_month_net_sales": per_month_net_sales,
            "totals": {
                "sales_sum": _sum(per_month_sales),
                "discounts_sum": _sum(per_month_discounts),
                "net_sales_sum": _sum(per_month_net_sales),
            },
        },
    }
    return out
def compute_consistency_metrics(
    beyan_metrics: Dict[str, Any],
    thk_metrics: Dict[str, Any],
    banka_metrics: Dict[str, Any],
) -> Dict[str, Any]:
    """
    1) Beyan ↔ Tahakkuk (hafif, bilgilendirici)
    2) Tahakkuk yükümlülükleri ↔ Banka 'tax_confirmed_rows' eşleştirmesi:
       - THN varsa: önce THN ile (öncelik: vade penceresi içinde; yoksa herhangi bir tarihte)
       - THN yoksa: vade penceresi + tutar toleransı

    Not: Ödeme bazı durumlarda vade dışında (gecikmeli) olabilir. THN eşleşmesi varsa, bunu
    yakalayıp 'thn_in_window' ile işaretliyoruz.
    """
    # safety init: ensure 'best' always exists before any reference
    best = None

    from datetime import datetime, timedelta

    def parse_date(s: str):
        s = (s or "").strip()
        for fmt in ("%d.%m.%Y", "%d/%m/%Y", "%Y-%m-%d"):
            try:
                return datetime.strptime(s, fmt).date()
            except Exception:
                pass
        return None

    def norm_thn(s):
        if not s:
            return None
        return str(s).strip().upper()

    # --- matching parameters (final) ---
    WINDOW_DAYS_BY_TYPE = {
        "KDV": 5,
        "KDV2": 7,
        "MUHTASAR": 15,
        "GECICI_KV": 15,
        "SGK": 10,
        "UNKNOWN": 10,
    }

    # tolerans: küçük tutarlar için 2 TL; büyükler için %0.5, en az 2 TL
    def tol_for(ttype: str, expected: float) -> float:
        base = 2.0
        pct = abs(expected) * 0.005
        tol = max(base, pct)
        # bazı türlerde biraz daha tolerans (bank komisyon/yuvarlama vb.)
        if ttype in ("MUHTASAR", "KDV2"):
            tol = max(tol, 3.0)
        return tol

    def window_for(ttype: str) -> int:
        return int(WINDOW_DAYS_BY_TYPE.get(ttype or "UNKNOWN", 10))

    # Banka satır havuzu
    bank_rows = (banka_metrics or {}).get("tax_confirmed_rows") or []
    bank_min = parse_date(banka_metrics.get("bank_date_min") or "") if banka_metrics else None
    bank_max = parse_date(banka_metrics.get("bank_date_max") or "") if banka_metrics else None

    # THN index (tüm satırlar)
    bank_by_thn: Dict[str, List[Dict[str, Any]]] = {}
    bank_tax_thn_rows = 0
    for br in bank_rows:
        if not isinstance(br, dict):
            continue
        thn = norm_thn(br.get("thn"))
        if thn:
            bank_by_thn.setdefault(thn, []).append(br)
            bank_tax_thn_rows += 1

    bank_tax_thn_unique = len(bank_by_thn)

    # --- yükümlülükleri (tahakkuk) normalize et ---
    per_type_t = ((thk_metrics or {}).get("per_type") or {})
    obligations: List[Dict[str, Any]] = []

    for ttype, d in per_type_t.items():
        pp = (d or {}).get("per_period") or {}
        for period, r in pp.items():
            r = r or {}
            vade = parse_date(r.get("vade") or "")
            if not vade:
                continue

            cash = _safe_float(r.get("odenecek_olan"))
            total = _safe_float(r.get("total_payable"))
            expected_total = total if total > 0 else 0.0
            expected_cash = cash if cash > 0 else 0.0

            targets = []
            if expected_total > 0:
                targets.append(("total_payable", expected_total))
            if expected_cash > 0 and (expected_cash != expected_total):
                targets.append(("odenecek_olan", expected_cash))
            if not targets:
                continue

            obligations.append(
                {
                    "type": ttype,
                    "period": period,
                    "vade": vade.isoformat(),
                    "expected_total": expected_total,
                    "expected_cash": expected_cash,
                    "thn": norm_thn(r.get("thn")),
                    "targets": targets,
                }
            )

    # --- eşleştirme ---
    payment_matching: List[Dict[str, Any]] = []
    matched_obligation_count = 0
    verified_obligation_count = 0
    verifiable_obligation_count = 0
    unmatched_obligation_count = 0
    unverifiable_obligation_count = 0

    expected_sum_verifiable = 0.0
    matched_sum_verifiable = 0.0
    expected_sum_all = 0.0
    matched_sum_all = 0.0

    for o in obligations:
        ttype = o["type"]
        vade = parse_date(o["vade"])
        thn = o.get("thn")
        targets = o["targets"]

        w = window_for(ttype)
        lo = vade - timedelta(days=w)
        hi = vade + timedelta(days=w)

        verifiable = True
        reason = None
        if bank_min is None or bank_max is None:
            verifiable = False
            reason = "bank_date_range_missing"
        else:
            if bank_max < lo or bank_min > hi:
                verifiable = False
                reason = "bank_range_outside_window"

        # window içindeki satırlar (fallback için)
        rows_in_window = []
        for br in bank_rows:
            bd = parse_date(br.get("tarih") or "")
            if not bd:
                continue
            if lo <= bd <= hi:
                rows_in_window.append(br)

        matched_rows: List[Dict[str, Any]] = []
        match_method = None
        matched_amount = 0.0
        expected_basis = None
        tol_used = None
        thn_in_window = None
        thn_seen_any = None

        # 1) THN ile dene (önce window, yoksa any-date)
        if thn:
            rows_any = bank_by_thn.get(thn) or []
            thn_seen_any = True if rows_any else False
            if rows_any:
                rows_win = []
                for br in rows_any:
                    bd = parse_date(br.get("tarih") or "")
                    if bd and lo <= bd <= hi:
                        rows_win.append(br)
                thn_in_window = True if rows_win else False
                candidates = rows_win if rows_win else rows_any

                cand_sum = sum(_safe_float(r.get("borc")) for r in candidates)
                for basis, target in targets:
                    tol = tol_for(ttype, target)
                    if abs(cand_sum - target) <= tol:
                        matched_rows = candidates
                        matched_amount = cand_sum
                        expected_basis = basis
                        tol_used = tol
                        match_method = "thn_sum_%s_%s" % (
                            basis,
                            ("in_window" if rows_win else "any_date"),
                        )
                        break

        # 2) Fallback: amount + window
        if not match_method:
            best = None
            best_score = None
            for basis, target in targets:
                tol = tol_for(ttype, target)
                for br in rows_in_window:
                    amt = _safe_float(br.get("borc"))
                    diff = abs(amt - target)
                    if diff <= tol:
                        bd = parse_date(br.get("tarih") or "") or vade
                        day_diff = abs((bd - vade).days)
                        score = diff + (day_diff * 0.01)  # aynı tutarda tarihe hafif öncelik
                        if best_score is None or score < best_score:
                            best_score = score
                            best = (basis, target, tol, br, amt)
            if best:
                basis, target, tol, br, amt = best
                matched_rows = [br]
                matched_amount = amt
                expected_basis = basis
                tol_used = tol
                match_method = "amount_in_window_%s" % basis

        # ödeme bağlamı (robust)
        payment_row = (matched_rows[0] if matched_rows else None)
        payment_date = (payment_row.get("tarih") if payment_row else None)

        days_from_vade = None
        if payment_date:
            bd = parse_date(str(payment_date))
            if bd:
                days_from_vade = (bd - vade).days

        paid_within_window = (abs(days_from_vade) <= w) if (days_from_vade is not None) else None

        if matched_amount > 0:
            if days_from_vade is None:
                payment_status = "PAID_UNKNOWN_DATE"
            elif days_from_vade < -w:
                payment_status = "PAID_EARLY"
            elif days_from_vade > w:
                payment_status = "PAID_LATE"
            else:
                payment_status = "PAID_ON_TIME"
        else:
            payment_status = ("UNPAID" if verifiable else "UNKNOWN")

        possible_offbank_payment = (matched_amount <= 0)

        if matched_amount > 0:
            smmm_action = "OK"
        else:
            smmm_action = ("CHECK_BANK_DATA_RANGE" if not verifiable else "CHECK_PAYMENT_OR_MATCHING_RULES")

        # metrik kayıt
        rec = {
            "type": ttype,
            "period": o["period"],
            "vade": o["vade"],
            "expected_total": o["expected_total"],
            "expected_cash": o["expected_cash"],
            "expected_basis": expected_basis,
            "tol": tol_used,
            "window_days": w,
            "verifiable": verifiable,
            "verifiable_reason": reason,
            "thn": thn,
            "thn_seen_any": thn_seen_any,
            "thn_in_window": thn_in_window,
            "match_method": match_method,
            "match_count": len(matched_rows),
            "matched_amount": matched_amount,
            "match_sample": (matched_rows[0] if matched_rows else None),
            "payment_date": payment_date,
            "days_from_vade": days_from_vade,
            "paid_within_window": paid_within_window,
            "payment_status": payment_status,
            "possible_offbank_payment": possible_offbank_payment,
            "smmm_action": smmm_action,
            "window_lo": lo.isoformat(),
            "window_hi": hi.isoformat(),
        }
        payment_matching.append(rec)

        # coverage (all obligations)
        exp_val_all = o["expected_total"] if o["expected_total"] > 0 else o["expected_cash"]
        expected_sum_all += exp_val_all
        if matched_amount > 0:
            matched_sum_all += matched_amount

        if verifiable:
            verifiable_obligation_count += 1
            # expected basis: önce total, sonra cash
            exp_val = o["expected_total"] if o["expected_total"] > 0 else o["expected_cash"]
            expected_sum_verifiable += exp_val
            if matched_amount > 0:
                matched_sum_verifiable += matched_amount

        if not verifiable:
            unverifiable_obligation_count += 1
        if matched_amount > 0:
            matched_obligation_count += 1
            if verifiable:
                verified_obligation_count += 1
        else:
            unmatched_obligation_count += 1

    # oranlar
    coverage_verified = (matched_sum_verifiable / expected_sum_verifiable) if expected_sum_verifiable else None
    bank_data_sufficient = bool(bank_rows) and (bank_min is not None) and (bank_max is not None)
    coverage_all = (matched_sum_all / expected_sum_all) if expected_sum_all else None
    evidence_level = "verified" if (bank_data_sufficient and coverage_verified is not None) else "partial"

    return {
        "bank_date_min": banka_metrics.get("bank_date_min") if banka_metrics else None,
        "bank_date_max": banka_metrics.get("bank_date_max") if banka_metrics else None,
        "bank_tax_thn_row_count": bank_tax_thn_rows,
        "bank_tax_thn_unique_count": bank_tax_thn_unique,
        "obligation_count": len(obligations),
        "verifiable_obligation_count": verifiable_obligation_count,
        "verified_obligation_count": verified_obligation_count,
        "matched_obligation_count": matched_obligation_count,
        "unmatched_obligation_count": unmatched_obligation_count,
        "unverifiable_obligation_count": unverifiable_obligation_count,
        "expected_sum_verifiable": expected_sum_verifiable,
        "matched_sum_verifiable": matched_sum_verifiable,
        "tax_payment_coverage_rate_verified": coverage_verified,
        "evidence_level": evidence_level,
        "tax_payment_coverage_rate": coverage_all,
        "bank_data_sufficient": bank_data_sufficient,
        "expected_sum_all": expected_sum_all,
        "matched_sum_all": matched_sum_all,
        "payment_matching": payment_matching,
        "obligations": payment_matching,  # geriye dönük uyumluluk (eski alan adı)
    }


def compute_scores(metrics: Dict[str, Any]) -> RiskScores:
    beyan = metrics.get("beyanname", {})
    mizan = metrics.get("mizan", {})
    banka = metrics.get("banka", {})
    edefter = metrics.get("edefter", {})
    cons = metrics.get("consistency", {})

    # --- Vergi uyum skoru (100 = iyi uyum, 0 = kötü uyum) ---
    tax_compliance = 100.0

    mismatch_total = _safe_float(cons.get("beyan_tahakkuk_mismatch_total"))
    mismatch_over_100 = int(cons.get("beyan_tahakkuk_mismatch_over_100") or 0)
    missing_forms = int(cons.get("missing_beyan_count") or 0) + int(cons.get("missing_tahakkuk_count") or 0)  # noqa
    coverage_rate = cons.get("tax_payment_coverage_rate_verified")
    if coverage_rate is None:
        coverage_rate = cons.get("tax_payment_coverage_rate")
    bank_ok = bool(cons.get("bank_data_sufficient"))
    verifiable = int(cons.get("verifiable_obligation_count") or 0)

    # Banka verisi dönem açısından yeterli değilse coverage_rate cezası uygulamayız.

    # Beyan–tahakkuk tutarlılığı: fark büyüdükçe uyum düşer
    tax_compliance -= min(40.0, mismatch_total / 1000.0 * 5.0)
    tax_compliance -= mismatch_over_100 * 5.0
    tax_compliance -= missing_forms * 10.0

    # Ödeme kapsamı: sadece "eksik ödeme" sinyalinde düşür.
    # coverage_rate > 1 çoğu zaman dönem kayması / sınıflandırma genişliği nedeniyle olabilir.
    if bank_ok and verifiable > 0 and coverage_rate is not None and coverage_rate < 0.95:
        tax_compliance -= 20.0

    tax_compliance = _clamp(tax_compliance)

    # KURGAN harmanı risk üzerinden yapılır (0 iyi, 100 kötü)
    tax_risk = 100.0 - tax_compliance

    # --- E-defter skoru ---
    total_lines = int(edefter.get("total_lines") or 0)
    kdv_ratio = _safe_float(edefter.get("kdv_line_ratio"))
    fx_lines = int(edefter.get("fx_lines") or 0)
    inflation_lines = int(edefter.get("inflation_lines") or 0)

    if total_lines == 0:
        edefter_score = 90.0  # veri yok → yüksek risk
    else:
        edefter_score = 30.0
        if kdv_ratio < 0.02:
            edefter_score += 20.0  # KDV ile ilgili satır oranı çok düşük
        if fx_lines > 0 and inflation_lines == 0:
            edefter_score += 20.0  # döviz var ama enflasyon/düzeltme izi yok
        if total_lines > 20000:
            edefter_score += 10.0  # çok büyük yevmiye → karmaşıklık

    edefter_score = _clamp(edefter_score)

    # --- SMİYB riski (sadece sayısal pattern) ---
    b_kdv = beyan.get("per_type", {}).get("KDV", {}).get("summary", {})
    b_kdv2 = beyan.get("per_type", {}).get("KDV2", {}).get("summary", {})
    kdv_matrah = _safe_float(b_kdv.get("matrah_toplami_sum"))
    kdv2_matrah = _safe_float(b_kdv2.get("matrah_sum"))
    pos_inflows = _safe_float(banka.get("pos_inflows"))
    receivables = _safe_float(mizan.get("receivables"))

    smiyb_score = 25.0
    if kdv_matrah > 0:
        ratio_kdv2 = kdv2_matrah / kdv_matrah
        if ratio_kdv2 > 0.1:
            smiyb_score += min(30.0, (ratio_kdv2 - 0.1) * 100.0)  # 0.4+ seviyede ekstra puan

    approx_turnover = kdv_matrah
    if approx_turnover > 0 and pos_inflows > approx_turnover * 1.2:
        smiyb_score += 20.0  # POS cirosu beyana göre çok yüksek

    if receivables > approx_turnover * 1.5:
        smiyb_score += 10.0  # alacaklar satışa göre çok yüksek

    smiyb_score = _clamp(smiyb_score)

    # --- Radar / yapısal risk ---
    total_current_assets = _safe_float(mizan.get("total_current_assets"))
    short_term_liab = _safe_float(mizan.get("short_term_liabilities"))
    equity_total = _safe_float(mizan.get("equity_total"))

    radar_score = 30.0
    if total_current_assets and short_term_liab:
        current_ratio = total_current_assets / short_term_liab
        if current_ratio < 1.0:
            radar_score += 25.0
        elif current_ratio < 1.2:
            radar_score += 15.0
        elif current_ratio < 1.5:
            radar_score += 5.0

    if equity_total <= 0:
        radar_score += 20.0  # negatif veya çok düşük özkaynak

    radar_score = _clamp(radar_score)

    # --- Enflasyon / kur risk skoru (kabaca, hukuki görüş değil) ---
    fx_lines = int(edefter.get("fx_lines") or 0)
    inflation_lines = int(edefter.get("inflation_lines") or 0)
    fx_exposed = fx_lines > 0

    inflation_score = 30.0
    if fx_exposed and inflation_lines == 0:
        inflation_score += 30.0  # döviz var, düzeltme izi yok
    elif fx_exposed and inflation_lines > 0:
        inflation_score += 10.0
    else:
        inflation_score += 5.0  # döviz yok → yine de genel enflasyon kontrolü gerekir

    inflation_score = _clamp(inflation_score)

    # --- Genel KURGAN skoru (blend) ---
    kurgan = (
        tax_risk * 0.3
        + smiyb_score * 0.25
        + radar_score * 0.2
        + edefter_score * 0.15
        + inflation_score * 0.1
    )

    kurgan = _clamp(kurgan)

    return RiskScores(
        kurgan_risk=kurgan,
        tax_compliance=tax_compliance,
        smiyb_risk=smiyb_score,
        radar_risk=radar_score,
        edefter_risk=edefter_score,
        inflation_risk=inflation_score,
    )


# ---------------------------------------------------------------------
# 8) KURAL TABANLI AI METİN KATI
# ---------------------------------------------------------------------
def build_ai_layer(
    smmm_id: str,
    client_id: str,
    period: str,
    metrics: Dict[str, Any],
    scores: RiskScores,
) -> Dict[str, Any]:
    """
    Dış LLM çağrısı yapmadan kural tabanlı Türkçe özet üretir.
    Hukuki sonuç cümlesi üretmez, sadece SMMM için checklist / tavsiye üretir.
    """
    cons = metrics.get("consistency", {})
    evidence = (cons.get("evidence_level") or "partial")
    mizan = metrics.get("mizan", {})
    edefter = metrics.get("edefter", {})

    def fmt_pct(x: Optional[Number]) -> str:
        if x is None:
            return "-"
        return f"{x*100:.1f}%"

    coverage_all = cons.get("tax_payment_coverage_rate")
    coverage_verified = cons.get("tax_payment_coverage_rate_verified")
    coverage_rate = coverage_verified if (evidence in ("verified","hybrid") and coverage_verified is not None) else coverage_all
    coverage_txt = fmt_pct(coverage_rate) if coverage_rate is not None else "-"
    evidence = cons.get("evidence_level") or ("verified" if cons.get("bank_data_sufficient") else "partial")
    bank_min = cons.get("bank_date_min")
    bank_max = cons.get("bank_date_max")
    exp_min = cons.get("bank_expected_min")
    exp_max = cons.get("bank_expected_max")


    summary_lines: List[str] = []

    # --- Banka ödeme eşleştirme: Unpaid VERIFIED vs PARTIAL ayrımı (AI anlatımı için) ---
    pm = cons.get("payment_matching", []) or []
    evidence = cons.get("evidence_level") or "partial"

    def _iso_date(s: str):
        try:
            return datetime.fromisoformat((s or "").strip()).date()
        except Exception:
            return None

    bank_min_d = _iso_date(cons.get("bank_date_min") or "")
    bank_max_d = _iso_date(cons.get("bank_date_max") or "")

    unpaid_verified = []
    unpaid_partial = []

    window_days = 10
    for o in pm:
        if not o.get("verifiable"):
            continue
        if (o.get("matched_amount") or 0) > 0:
            continue

        # window_lo/window_hi yoksa vade±window_days ile hesapla (robust)
        lo = _iso_date(o.get("window_lo") or "")
        hi = _iso_date(o.get("window_hi") or "")
        if lo is None or hi is None:
            vd = _iso_date(o.get("vade") or "")
            if vd:
                from datetime import timedelta
                lo = vd - timedelta(days=window_days)
                hi = vd + timedelta(days=window_days)

        # pencere tamamen banka aralığı içinde mi?
        if bank_min_d and bank_max_d and lo and hi and (bank_min_d <= lo) and (bank_max_d >= hi):
            unpaid_verified.append(o)
        else:
            unpaid_partial.append(o)

    summary_lines.append(
        f"{client_id} için {period} dönemi verileri (beyanname, tahakkuk, mizan, banka, e-defter) birlikte analiz edildi."
    )
    summary_lines.append(
        f"Kurgan toplam risk skoru: {scores.kurgan_risk:.1f} / 100 "
        f"(Vergi uyumu: {scores.tax_compliance:.1f}, SMİYB: {scores.smiyb_risk:.1f}, "
        f"Yapısal radar: {scores.radar_risk:.1f}, E-defter: {scores.edefter_risk:.1f}, Enflasyon: {scores.inflation_risk:.1f})."
    )
    if evidence == "verified" and coverage_rate is not None:
        summary_lines.append(
            f"Tahakkuk eden vergilerin banka hareketleri üzerinden ödeme kapsam oranı yaklaşık {coverage_txt} seviyesinde."
        )
    elif evidence == "hybrid" and coverage_rate is not None:
        thn_cnt = int(cons.get("thn_matched_obligation_count") or 0)
        ver_cnt = int(cons.get("verified_obligation_count") or 0)
        summary_lines.append(
            "Uyarı: Banka hareketleri bu dönemin vade penceresini tam kapsamıyor; "
            f"ancak THN üzerinden {thn_cnt} ödeme doğrulandı. "
            f"Mevcut banka aralığında tamamen kapsanan {ver_cnt} yükümlülük için ödeme kapsam oranı yaklaşık {coverage_txt}. "
            "Bu oran bilgi amaçlıdır; skora ceza uygulanmaz."
        )

    elif evidence == "partial" and coverage_rate is not None:
        summary_lines.append(
            "Uyarı: Banka hareketleri bu dönemin vade penceresini tam kapsamıyor "
            f"(mevcut: {bank_min} → {bank_max}, beklenen: {exp_min} → {exp_max}). "
            f"Bu nedenle ödeme kapsam oranı ({coverage_txt}) yalnızca bilgi amaçlıdır; skora ceza uygulanmaz."
        )


    # Unpaid VERIFIED ise (pencere tamamen kapsanıyor ama ödeme yok) bunu ayrıca özetle
    if unpaid_verified:
        ex = unpaid_verified[:3]
        ex_txt = ", ".join(f'{x.get("type")} {x.get("period")} vade={x.get("vade")} expected={x.get("expected")}' for x in ex)
        summary_lines.append(
            f"Not: Banka aralığında tamamen kapsanan {len(unpaid_verified)} yükümlülük için ödeme hareketi görünmedi (örnek: {ex_txt})."
        )
    # Checklist
    checklist: List[str] = []

    if unpaid_verified:
        checklist.append(
            f"Banka aralığında tamamen kapsanan yükümlülüklerde ödeme görünmeyen {len(unpaid_verified)} kalem var; farklı banka hesabı/şube/kanal, mahsup-parçalı ödeme veya gecikme ihtimalini kontrol edin."
        )
    if unpaid_partial:
        checklist.append(
            f"Banka aralığı vade penceresini kesen {len(unpaid_partial)} kalem var; ilgili aylara ait eksik banka CSV'leri geldikçe bu kalemler yeniden doğrulanmalıdır."
        )
    if _safe_float(cons.get("beyan_tahakkuk_mismatch_total")) > 0:
        checklist.append(
            "Beyanname ile tahakkuk tutarları arasındaki farkları (özellikle 100 TL üzeri olanları) tek tek kontrol edin."
        )
    if evidence == "verified" and coverage_rate is not None and (coverage_rate < 0.95 or coverage_rate > 1.05):
        checklist.append(
            "Banka hesap hareketlerinde vergi dairesi ödemeleri ile tahakkuk toplamlarını karşılaştırın; eksik veya fazla ödeme var mı?"
        )
    if _safe_float(mizan.get("equity_total")) <= 0:
        checklist.append(
            "Özkaynakların negatif veya çok zayıf olup olmadığını kontrol edin; sermaye tamamlama / güçlendirme ihtiyacını değerlendirin."
        )
    if int(edefter.get("fx_lines") or 0) > 0 and int(edefter.get("inflation_lines") or 0) == 0:
        checklist.append(
            "Dövizli işlemler için kur değerlemesi ve enflasyon muhasebesi kayıtlarının (varsa) doğru yapıldığını doğrulayın."
        )
    if not checklist:
        checklist.append(
            "Bu dönem için kritik bir alarm görünmüyor; yine de örnekleme yoluyla birkaç beyanname, banka hareketi ve yevmiye kaydını manuel kontrol edin."
        )

    advice_lines: List[str] = []
    advice_lines.append(
        "Bu çıktı, sayısal tutarlılık ve oran analizi yapar; hukuki nitelikte bir vergi görüşü değildir."
    )
    advice_lines.append(
        "Herhangi bir önemli fark veya yüksek risk görülen alan için, ilgili beyannameleri, tahakkuk fişlerini ve e-defter kayıtlarını resmi mevzuat çerçevesinde detaylı inceleyin."
    )
    advice_lines.append(
        "Özellikle enflasyon muhasebesi ve kur değerlemesi konularında, güncel Vergi Usul Kanunu düzenlemeleri ve Gelir İdaresi Başkanlığı özelgeleri esas alınmalıdır."
    )

    return {
        "summary": "\n".join(summary_lines),
        "checklist": "\n".join(f"- {item}" for item in checklist),
        "advice": "\n".join(advice_lines),
    }


# ---------------------------------------------------------------------
# 9) DIŞA AÇILAN ANA FONKSİYON
# ---------------------------------------------------------------------
def run_risk_model_v1(
    base_dir: str,
    smmm_id: str,
    client_id: str,
    period: str,
) -> Dict[str, Any]:
    """Run Lyntos Risk Model v1 for a given SMMM/client/period."""
    base_path = Path(base_dir)

    raw = load_all_for_client_period(
        base_dir=base_path,
        smmm_id=smmm_id,
        client_id=client_id,
        period=period,
    ) or {}

    # loader isimleri farklı olabilir; toleranslı ol
    beyan_list = raw.get("beyanname") or raw.get("beyan") or []
    thk_list = raw.get("tahakkuk") or raw.get("thk") or []
    banka_list = raw.get("banka") or []
    mizan_list = raw.get("mizan") or []
    edefter_list = raw.get("edefter") or []

    beyan_metrics = compute_beyanname_metrics(beyan_list)
    thk_metrics = compute_tahakkuk_metrics(thk_list)
    banka_metrics = compute_banka_metrics(banka_list, period=period)
    mizan_metrics = compute_mizan_metrics(mizan_list)
    edefter_metrics = compute_edefter_metrics(edefter_list)

    consistency_metrics = compute_consistency_metrics(beyan_metrics, thk_metrics, banka_metrics)

    metrics = {
        "beyanname": beyan_metrics,
        "tahakkuk": thk_metrics,
        "banka": banka_metrics,
        "mizan": mizan_metrics,
        "edefter": edefter_metrics,
        "consistency": consistency_metrics,
    }


    # --- Kural motoru (VDK tarzı senaryo / tutarlılık kontrolleri) ---
    # Not: Rule engine 'config' zorunlu olduğu için DEFAULT_CONFIG ile çalıştırıyoruz.
    try:
        from risk_model.v1_rule_engine import RiskAnalyzer, DEFAULT_CONFIG, AccountParser
        mizan_deep = AccountParser().process_mizan(mizan_list)
        rules_out = RiskAnalyzer(DEFAULT_CONFIG).analyze(
            mizan_deep=mizan_deep,
            beyan_metrics=beyan_metrics,
            bank_metrics=banka_metrics,
            period=period,
            sector=None,
        )
    except Exception as e:
        rules_out = {
            "period": period,
            "sector": None,
            "risks": [],
            "risk_count": 0,
            "severity_counts": {},
            "error": f"rule_engine_failed: {e.__class__.__name__}: {e}",
        }

    metrics["rules"] = rules_out
    # Enrich selected risks with SMMM-grade explanations/actions/checklists
    try:
        from risk_model.risk_enrich import enrich_rules_in_metrics
        enrich_rules_in_metrics(metrics, period=locals().get('period'))
    except Exception:
        pass

    # --- rules_summary: raporlama/ekran için kısa, denetlenebilir özet ---
    try:
        _r = metrics.get("rules") or {}
        _risks = _r.get("risks") or []
        _top = _risks[:5]
        rules_summary = {
            "period": _r.get("period"),
            "sector": _r.get("sector"),
            "risk_count": _r.get("risk_count", len(_risks)),
            "severity_counts": _r.get("severity_counts") or {},
            "top_risks": [
                {
                    "code": x.get("code"),
                    "title": x.get("title"),
                    "severity": x.get("severity"),
                    "value_found": x.get("value_found"),
                    "threshold": x.get("threshold"),
                    "evidence": x.get("evidence"),
                    "description": x.get("description"),
                    # hukuki hüküm yok: sadece kontrol aksiyonu
                    "recommended_action": "Mizan–beyan mutabakatını belge bazında kontrol edin; ilgili hesaplar (600/601/602/391/191 vb.) ve dönem kırılımını doğrulayın; gerekiyorsa tahakkuk/beyan düzeltmesini değerlendirin."
                }
                for x in _top
            ],
        }
    except Exception as e:
        rules_summary = {
            "risk_count": 0,
            "severity_counts": {},
            "top_risks": [],
            "error": f"rules_summary_failed: {e.__class__.__name__}: {e}",
        }

    metrics["rules_summary"] = rules_summary

    scores = compute_scores(metrics)
    ai_layer = build_ai_layer(smmm_id, client_id, period, metrics, scores)

    # rules_summary -> AI layer bridge (sadece raporlama, hukuki hüküm değil)
    try:
        _ai = locals().get('ai_layer', None)
        if _ai is None:
            _ai = locals().get('ai', None)
        if isinstance(_ai, dict):
            _ai['rules_summary'] = metrics.get('rules_summary')
    except Exception:
        pass

    return {
        "ok": True,
        "version": "v1",
        "smmm_id": smmm_id,
        "client_id": client_id,
        "period": period,
        "metrics": metrics,
        "scores": asdict(scores),
        "ai": ai_layer,
    }

