from __future__ import annotations
import re

from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Dict, List, Optional

from data_engine.loader import load_all_for_client_period


Number = float  # sade okunurluk için


@dataclass
class RiskScores:
    kurgan_risk: Number
    tax_compliance: Number
    smiyb_risk: Number
    radar_risk: Number
    edefter_risk: Number
    inflation_risk: Number


def _safe_float(value: Any, default: Number = 0.0) -> Number:
    if value is None:
        return default
    try:
        return float(str(value).replace(",", "."))
    except Exception:
        return default


def _first_digit(hesap_kodu: str) -> Optional[str]:
    if not hesap_kodu:
        return None
    for ch in str(hesap_kodu):
        if ch.isdigit():
            return ch
    return None


def _clamp(value: Number, lo: Number = 0.0, hi: Number = 100.0) -> Number:
    return max(lo, min(hi, value))


# ---------------------------------------------------------------------
# 1) BEYANNAME METRİKLERİ
# ---------------------------------------------------------------------
def compute_beyanname_metrics(beyan_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Beyannameleri tür ve dönem bazında özetler.

    Çıktı:
    {
      "per_type": {
          "KDV": {
              "per_period": { "2025-04": {...}, ... },
              "summary": {...}
          },
          ...
      },
      "periods": ["2025-04", "2025-05", ...]
    }
    """
    per_type: Dict[str, Dict[str, Dict[str, Any]]] = {}
    periods: set[str] = set()

    for rec in beyan_list:
        btype = rec.get("beyan_type") or "UNKNOWN"
        period = rec.get("period")  # e.g. "2025-06"
        details = rec.get("details") or {}
        if not period:
            continue
        periods.add(period)
        per_type.setdefault(btype, {}).setdefault("per_period", {})

        if btype == "KDV":
            per_type[btype]["per_period"][period] = {
                "matrah_toplami": _safe_float(details.get("matrah_toplami")),
                "hesaplanan_kdv": _safe_float(details.get("hesaplanan_kdv")),
                "toplam_kdv": _safe_float(details.get("toplam_kdv")),
                "onceki_devreden_ind_kdv": _safe_float(details.get("onceki_devreden_ind_kdv")),
                "indirimler_toplami": _safe_float(details.get("indirimler_toplami")),
            }
        elif btype == "KDV2":
            per_type[btype]["per_period"][period] = {
                "matrah": _safe_float(details.get("matrah")),
                "tevkif_edilen_kdv": _safe_float(details.get("tevkif_edilen_kdv")),
                "odenecek_kdv": _safe_float(details.get("odenecek_kdv")),
            }
        elif btype == "MUHTASAR":
            per_type[btype]["per_period"][period] = {
                "mahsup_edilecek_toplam_vergi": _safe_float(details.get("mahsup_edilecek_toplam_vergi")),
                "tevkifata_iliskin_damga_vergisi": _safe_float(details.get("tevkifata_iliskin_damga_vergisi")),
            }
        elif btype == "GECICI_KV":
            per_type[btype]["per_period"][period] = {
                "ticari_bilanco_kari": _safe_float(details.get("ticari_bilanco_kari")),
                "ticari_bilanco_zarari": _safe_float(details.get("ticari_bilanco_zarari")),
                "gecici_vergi_matrahi": _safe_float(details.get("gecici_vergi_matrahi")),
                "hesaplanan_gecici_vergi": _safe_float(details.get("hesaplanan_gecici_vergi")),
            }
        else:
            # bilinmeyen tipleri ham detayla saklıyoruz
            per_type[btype]["per_period"][period] = {
                "raw": details
            }

    # Özetler
    for btype, data in per_type.items():
        per_period = data.get("per_period", {})
        summary: Dict[str, Number] = {}
        for pvals in per_period.values():
            for key, val in pvals.items():
                if isinstance(val, (int, float)):
                    summary[key + "_sum"] = summary.get(key + "_sum", 0.0) + float(val)
        per_type[btype]["summary"] = summary

    return {
        "per_type": per_type,
        "periods": sorted(periods),
    }


# ---------------------------------------------------------------------
# 2) TAHAKKUK METRİKLERİ
# ---------------------------------------------------------------------
def compute_tahakkuk_metrics(thk_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    per_type: Dict[str, Dict[str, Dict[str, Any]]] = {}
    periods: set[str] = set()

    for rec in thk_list:
        ttype = rec.get("tax_type") or "UNKNOWN"
        period = rec.get("period")
        if not period:
            continue
        periods.add(period)
        per_type.setdefault(ttype, {}).setdefault("per_period", {})

        main_row = rec.get("main_row") or {}
        per_type[ttype]["per_period"][period] = {
            "matrah": _safe_float(main_row.get("matrah")),
            "tahakkuk_eden": _safe_float(main_row.get("tahakkuk_eden")),
            "mahsup_edilen": _safe_float(main_row.get("mahsup_edilen")),
            "odenecek_olan": _safe_float(main_row.get("odenecek_olan")),
            "total_payable": _safe_float(rec.get("total_payable")),
            "acceptance_date": rec.get("acceptance_date"),
            "issue_date": rec.get("issue_date"),
            "vade": (main_row.get("vade") or ""),
            "thn": (rec.get("thn") or "").strip().upper(),
            "source_file": rec.get("source_file"),
        }

    # özetler
    for ttype, data in per_type.items():
        per_period = data.get("per_period", {})
        summary: Dict[str, Number] = {}
        for pvals in per_period.values():
            for key, val in pvals.items():
                if isinstance(val, (int, float)):
                    summary[key + "_sum"] = summary.get(key + "_sum", 0.0) + float(val)
        per_type[ttype]["summary"] = summary

    return {
        "per_type": per_type,
        "periods": sorted(periods),
    }


# ---------------------------------------------------------------------
# 3) MİZAN METRİKLERİ (yapısal / radar için)
# ---------------------------------------------------------------------
def compute_mizan_metrics(mizan_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Mizan satırlarından ana sınıf bazlı özetler üretir.
    """
    class_sums: Dict[str, Dict[str, Number]] = {}
    kdv_accounts: Dict[str, Number] = {}
    equity_total = 0.0

    for row in mizan_list:
        code = str(row.get("hesap_kodu") or "")
        first = _first_digit(code)
        bakiye_borc = _safe_float(row.get("bakiye_borc"))
        bakiye_alacak = _safe_float(row.get("bakiye_alacak"))
        net = bakiye_borc - bakiye_alacak

        if first:
            cs = class_sums.setdefault(first, {"bakiye_borc": 0.0, "bakiye_alacak": 0.0, "net": 0.0})
            cs["bakiye_borc"] += bakiye_borc
            cs["bakiye_alacak"] += bakiye_alacak
            cs["net"] += net

        # KDV ilişkili hesaplar
        if code.startswith("191") or code.startswith("190") or code.startswith("360"):
            kdv_accounts[code] = kdv_accounts.get(code, 0.0) + net

        # Özkaynak sınıfı (5xx)
        if code.startswith("5"):
            equity_total += net

    assets_net = class_sums.get("1", {}).get("net", 0.0) + class_sums.get("2", {}).get("net", 0.0)
    liab_net = (
        class_sums.get("3", {}).get("net", 0.0)
        + class_sums.get("4", {}).get("net", 0.0)
        + class_sums.get("5", {}).get("net", 0.0)
    )

    # Basit likidite göstergeleri
    cash_bank = 0.0
    receivables = 0.0
    inventory = 0.0
    short_term_liab = 0.0

    for row in mizan_list:
        code = str(row.get("hesap_kodu") or "")
        net = _safe_float(row.get("bakiye_borc")) - _safe_float(row.get("bakiye_alacak"))

        if code.startswith(("10", "100", "101", "102")):
            cash_bank += net
        if code.startswith(("12", "120", "121")):
            receivables += net
        if code.startswith(("15", "150", "153")):
            inventory += net
        if code.startswith(("30", "300", "320", "321", "329", "33", "331", "332", "333", "336")):
            short_term_liab += abs(net)

    total_current_assets = cash_bank + receivables + inventory

    return {
        "class_sums": class_sums,
        "assets_net": assets_net,
        "liabilities_equity_net": liab_net,
        "equity_total": equity_total,
        "cash_bank": cash_bank,
        "receivables": receivables,
        "inventory": inventory,
        "short_term_liabilities": short_term_liab,
        "total_current_assets": total_current_assets,
        "kdv_accounts": kdv_accounts,
    }


# ---------------------------------------------------------------------
# 4) BANKA METRİKLERİ
# ---------------------------------------------------------------------
def compute_banka_metrics(banka_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Banka hareketlerinden:
      - tarih aralığı (bank_date_min/max)
      - satır sayısı (bank_row_count)
      - 'vergi/SGK ödeme' olduğuna kuvvetli işaret taşıyan satırları (tax_confirmed_rows)
        * Not: Banka tarafında açıklama formatları değişebildiği için burada muhafazakâr
          bir doğrulama yapılır. Asıl eşleştirme (THN + tolerans + vade penceresi) tutarlılık
          metriğinde yapılır.

    Beklenen alanlar (parser'dan):
      tarih, borc, alacak, aciklama, detay, source_file (opsiyonel)
    """
    from datetime import datetime

    def parse_date(s: str):
        s = (s or "").strip()
        for fmt in ("%Y-%m-%d", "%d.%m.%Y", "%d/%m/%Y"):
            try:
                return datetime.strptime(s, fmt).date()
            except Exception:
                pass
        return None

    thn_re = re.compile(r"(20\d{6}01M[A-Za-z0-9]{2,4}\d{7})", re.IGNORECASE)

    bank_min = None
    bank_max = None
    tax_confirmed_rows: List[Dict[str, Any]] = []
    bank_row_count = 0

    for row in banka_list or []:
        if not isinstance(row, dict):
            continue
        bank_row_count += 1

        d = parse_date(str(row.get("tarih") or ""))
        if d:
            bank_min = d if bank_min is None else min(bank_min, d)
            bank_max = d if bank_max is None else max(bank_max, d)

        borc = _safe_float(row.get("borc"))
        if borc <= 0:
            continue

        desc_raw = str(row.get("aciklama") or "")
        detay = str(row.get("detay") or "")
        desc_full = (desc_raw + " " + detay).strip()
        desc_u = desc_full.upper()

        # --- muhafazakâr 'vergi ödeme' sinyali ---
        # VERGI-/VERGİ- prefiksi, G.STOPAJ, KDV, GEÇİCİ vb.
        is_taxish = (
            ("VERGI-" in desc_u)
            or ("VERGİ-" in desc_u)
            or ("G.STOPAJ" in desc_u)
            or ("STOPAJ" in desc_u)
            or ("KDV" in desc_u)
            or ("GEÇİCİ" in desc_u)
            or ("GECICI" in desc_u)
            or ("SGK" in desc_u)
        )

        if not is_taxish:
            continue

        m_thn = thn_re.search(desc_full)
        thn = (m_thn.group(1) if m_thn else None)
        if thn:
            thn = thn.strip().upper()

        tax_confirmed_rows.append(
            {
                "tarih": d.isoformat() if d else None,
                "borc": borc,
                "aciklama": desc_full,
                "thn": thn,
                "source_file": row.get("source_file"),
            }
        )

    return {
        "bank_row_count": bank_row_count,
        "bank_date_min": bank_min.isoformat() if bank_min else None,
        "bank_date_max": bank_max.isoformat() if bank_max else None,
        "tax_confirmed_rows": tax_confirmed_rows,
    }


def compute_edefter_metrics(edefter_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    total_lines = len(edefter_list)
    kdv_lines = 0
    fx_lines = 0
    inflation_lines = 0

    for row in edefter_list:
        code = str(row.get("hesap_kodu") or "")
        name = (row.get("hesap_adi") or "").upper()
        aciklama = (row.get("aciklama") or "").upper()
        detay = (row.get("detay") or "").upper()

        text = name + " " + aciklama + " " + detay

        if code.startswith(("190", "191", "360")) or "KDV" in text:
            kdv_lines += 1

        if any(token in text for token in ["USD", "EUR", "DOLAR", "EURO", "STERLIN"]):
            fx_lines += 1

        if "ENFLASYON" in text or "DÜZELTME" in text or "ENF.DÜZ" in text:
            inflation_lines += 1

    return {
        "total_lines": total_lines,
        "kdv_lines": kdv_lines,
        "fx_lines": fx_lines,
        "inflation_lines": inflation_lines,
        "kdv_line_ratio": (kdv_lines / total_lines) if total_lines else 0.0,
    }


# ---------------------------------------------------------------------
# 6) TUTARLILIK / UYUM METRİKLERİ (Beyan + Tahakkuk + Banka)
# ---------------------------------------------------------------------
def compute_consistency_metrics(
    beyan_metrics: Dict[str, Any],
    thk_metrics: Dict[str, Any],
    banka_metrics: Dict[str, Any],
) -> Dict[str, Any]:
    """
    1) Beyan ↔ Tahakkuk (hafif, bilgilendirici)
    2) Tahakkuk yükümlülükleri ↔ Banka 'tax_confirmed_rows' eşleştirmesi:
       - THN varsa: önce THN ile (öncelik: vade penceresi içinde; yoksa herhangi bir tarihte)
       - THN yoksa: vade penceresi + tutar toleransı

    Not: Ödeme bazı durumlarda vade dışında (gecikmeli) olabilir. THN eşleşmesi varsa, bunu
    yakalayıp 'thn_in_window' ile işaretliyoruz.
    """
    # safety init: ensure 'best' always exists before any reference
    best = None

    from datetime import datetime, timedelta

    def parse_date(s: str):
        s = (s or "").strip()
        for fmt in ("%d.%m.%Y", "%d/%m/%Y", "%Y-%m-%d"):
            try:
                return datetime.strptime(s, fmt).date()
            except Exception:
                pass
        return None

    def norm_thn(s):
        if not s:
            return None
        return str(s).strip().upper()

    # --- matching parameters (final) ---
    WINDOW_DAYS_BY_TYPE = {
        "KDV": 5,
        "KDV2": 7,
        "MUHTASAR": 15,
        "GECICI_KV": 15,
        "SGK": 10,
        "UNKNOWN": 10,
    }

    # tolerans: küçük tutarlar için 2 TL; büyükler için %0.5, en az 2 TL
    def tol_for(ttype: str, expected: float) -> float:
        base = 2.0
        pct = abs(expected) * 0.005
        tol = max(base, pct)
        # bazı türlerde biraz daha tolerans (bank komisyon/yuvarlama vb.)
        if ttype in ("MUHTASAR", "KDV2"):
            tol = max(tol, 3.0)
        return tol

    def window_for(ttype: str) -> int:
        return int(WINDOW_DAYS_BY_TYPE.get(ttype or "UNKNOWN", 10))

    # Banka satır havuzu
    bank_rows = (banka_metrics or {}).get("tax_confirmed_rows") or []
    bank_min = parse_date(banka_metrics.get("bank_date_min") or "") if banka_metrics else None
    bank_max = parse_date(banka_metrics.get("bank_date_max") or "") if banka_metrics else None

    # THN index (tüm satırlar)
    bank_by_thn: Dict[str, List[Dict[str, Any]]] = {}
    bank_tax_thn_rows = 0
    for br in bank_rows:
        if not isinstance(br, dict):
            continue
        thn = norm_thn(br.get("thn"))
        if thn:
            bank_by_thn.setdefault(thn, []).append(br)
            bank_tax_thn_rows += 1

    bank_tax_thn_unique = len(bank_by_thn)

    # --- yükümlülükleri (tahakkuk) normalize et ---
    per_type_t = ((thk_metrics or {}).get("per_type") or {})
    obligations: List[Dict[str, Any]] = []

    for ttype, d in per_type_t.items():
        pp = (d or {}).get("per_period") or {}
        for period, r in pp.items():
            r = r or {}
            vade = parse_date(r.get("vade") or "")
            if not vade:
                continue

            cash = _safe_float(r.get("odenecek_olan"))
            total = _safe_float(r.get("total_payable"))
            expected_total = total if total > 0 else 0.0
            expected_cash = cash if cash > 0 else 0.0

            targets = []
            if expected_total > 0:
                targets.append(("total_payable", expected_total))
            if expected_cash > 0 and (expected_cash != expected_total):
                targets.append(("odenecek_olan", expected_cash))
            if not targets:
                continue

            obligations.append(
                {
                    "type": ttype,
                    "period": period,
                    "vade": vade.isoformat(),
                    "expected_total": expected_total,
                    "expected_cash": expected_cash,
                    "thn": norm_thn(r.get("thn")),
                    "targets": targets,
                }
            )

    # --- eşleştirme ---
    payment_matching: List[Dict[str, Any]] = []
    matched_obligation_count = 0
    verified_obligation_count = 0
    verifiable_obligation_count = 0
    unmatched_obligation_count = 0
    unverifiable_obligation_count = 0

    expected_sum_verifiable = 0.0
    matched_sum_verifiable = 0.0
    expected_sum_all = 0.0
    matched_sum_all = 0.0

    for o in obligations:
        ttype = o["type"]
        vade = parse_date(o["vade"])
        thn = o.get("thn")
        targets = o["targets"]

        w = window_for(ttype)
        lo = vade - timedelta(days=w)
        hi = vade + timedelta(days=w)

        verifiable = True
        reason = None
        if bank_min is None or bank_max is None:
            verifiable = False
            reason = "bank_date_range_missing"
        else:
            if bank_max < lo or bank_min > hi:
                verifiable = False
                reason = "bank_range_outside_window"

        # window içindeki satırlar (fallback için)
        rows_in_window = []
        for br in bank_rows:
            bd = parse_date(br.get("tarih") or "")
            if not bd:
                continue
            if lo <= bd <= hi:
                rows_in_window.append(br)

        matched_rows: List[Dict[str, Any]] = []
        match_method = None
        matched_amount = 0.0
        expected_basis = None
        tol_used = None
        thn_in_window = None
        thn_seen_any = None

        # 1) THN ile dene (önce window, yoksa any-date)
        if thn:
            rows_any = bank_by_thn.get(thn) or []
            thn_seen_any = True if rows_any else False
            if rows_any:
                rows_win = []
                for br in rows_any:
                    bd = parse_date(br.get("tarih") or "")
                    if bd and lo <= bd <= hi:
                        rows_win.append(br)
                thn_in_window = True if rows_win else False
                candidates = rows_win if rows_win else rows_any

                cand_sum = sum(_safe_float(r.get("borc")) for r in candidates)
                for basis, target in targets:
                    tol = tol_for(ttype, target)
                    if abs(cand_sum - target) <= tol:
                        matched_rows = candidates
                        matched_amount = cand_sum
                        expected_basis = basis
                        tol_used = tol
                        match_method = "thn_sum_%s_%s" % (
                            basis,
                            ("in_window" if rows_win else "any_date"),
                        )
                        break

        # 2) Fallback: amount + window
        if not match_method:
            best = None
            best_score = None
            for basis, target in targets:
                tol = tol_for(ttype, target)
                for br in rows_in_window:
                    amt = _safe_float(br.get("borc"))
                    diff = abs(amt - target)
                    if diff <= tol:
                        bd = parse_date(br.get("tarih") or "") or vade
                        day_diff = abs((bd - vade).days)
                        score = diff + (day_diff * 0.01)  # aynı tutarda tarihe hafif öncelik
                        if best_score is None or score < best_score:
                            best_score = score
                            best = (basis, target, tol, br, amt)
            if best:
                basis, target, tol, br, amt = best
                matched_rows = [br]
                matched_amount = amt
                expected_basis = basis
                tol_used = tol
                match_method = "amount_in_window_%s" % basis

        # ödeme bağlamı (robust)
        payment_row = (matched_rows[0] if matched_rows else None)
        payment_date = (payment_row.get("tarih") if payment_row else None)

        days_from_vade = None
        if payment_date:
            bd = parse_date(str(payment_date))
            if bd:
                days_from_vade = (bd - vade).days

        paid_within_window = (abs(days_from_vade) <= w) if (days_from_vade is not None) else None

        if matched_amount > 0:
            if days_from_vade is None:
                payment_status = "PAID_UNKNOWN_DATE"
            elif days_from_vade < -w:
                payment_status = "PAID_EARLY"
            elif days_from_vade > w:
                payment_status = "PAID_LATE"
            else:
                payment_status = "PAID_ON_TIME"
        else:
            payment_status = ("UNPAID" if verifiable else "UNKNOWN")

        possible_offbank_payment = (matched_amount <= 0)

        if matched_amount > 0:
            smmm_action = "OK"
        else:
            smmm_action = ("CHECK_BANK_DATA_RANGE" if not verifiable else "CHECK_PAYMENT_OR_MATCHING_RULES")

        # metrik kayıt
        rec = {
            "type": ttype,
            "period": o["period"],
            "vade": o["vade"],
            "expected_total": o["expected_total"],
            "expected_cash": o["expected_cash"],
            "expected_basis": expected_basis,
            "tol": tol_used,
            "window_days": w,
            "verifiable": verifiable,
            "verifiable_reason": reason,
            "thn": thn,
            "thn_seen_any": thn_seen_any,
            "thn_in_window": thn_in_window,
            "match_method": match_method,
            "match_count": len(matched_rows),
            "matched_amount": matched_amount,
            "match_sample": (matched_rows[0] if matched_rows else None),
            "payment_date": payment_date,
            "days_from_vade": days_from_vade,
            "paid_within_window": paid_within_window,
            "payment_status": payment_status,
            "possible_offbank_payment": possible_offbank_payment,
            "smmm_action": smmm_action,
            "window_lo": lo.isoformat(),
            "window_hi": hi.isoformat(),
        }
        payment_matching.append(rec)

        # coverage (all obligations)
        exp_val_all = o["expected_total"] if o["expected_total"] > 0 else o["expected_cash"]
        expected_sum_all += exp_val_all
        if matched_amount > 0:
            matched_sum_all += matched_amount

        if verifiable:
            verifiable_obligation_count += 1
            # expected basis: önce total, sonra cash
            exp_val = o["expected_total"] if o["expected_total"] > 0 else o["expected_cash"]
            expected_sum_verifiable += exp_val
            if matched_amount > 0:
                matched_sum_verifiable += matched_amount

        if not verifiable:
            unverifiable_obligation_count += 1
        if matched_amount > 0:
            matched_obligation_count += 1
            if verifiable:
                verified_obligation_count += 1
        else:
            unmatched_obligation_count += 1

    # oranlar
    coverage_verified = (matched_sum_verifiable / expected_sum_verifiable) if expected_sum_verifiable else None
    bank_data_sufficient = bool(bank_rows) and (bank_min is not None) and (bank_max is not None)
    coverage_all = (matched_sum_all / expected_sum_all) if expected_sum_all else None
    evidence_level = "verified" if (bank_data_sufficient and coverage_verified is not None) else "partial"

    return {
        "bank_date_min": banka_metrics.get("bank_date_min") if banka_metrics else None,
        "bank_date_max": banka_metrics.get("bank_date_max") if banka_metrics else None,
        "bank_tax_thn_row_count": bank_tax_thn_rows,
        "bank_tax_thn_unique_count": bank_tax_thn_unique,
        "obligation_count": len(obligations),
        "verifiable_obligation_count": verifiable_obligation_count,
        "verified_obligation_count": verified_obligation_count,
        "matched_obligation_count": matched_obligation_count,
        "unmatched_obligation_count": unmatched_obligation_count,
        "unverifiable_obligation_count": unverifiable_obligation_count,
        "expected_sum_verifiable": expected_sum_verifiable,
        "matched_sum_verifiable": matched_sum_verifiable,
        "tax_payment_coverage_rate_verified": coverage_verified,
        "evidence_level": evidence_level,
        "tax_payment_coverage_rate": coverage_all,
        "bank_data_sufficient": bank_data_sufficient,
        "expected_sum_all": expected_sum_all,
        "matched_sum_all": matched_sum_all,
        "payment_matching": payment_matching,
        "obligations": payment_matching,  # geriye dönük uyumluluk (eski alan adı)
    }


def compute_scores(metrics: Dict[str, Any]) -> RiskScores:
    beyan = metrics.get("beyanname", {})
    mizan = metrics.get("mizan", {})
    banka = metrics.get("banka", {})
    edefter = metrics.get("edefter", {})
    cons = metrics.get("consistency", {})

    # --- Vergi uyum skoru (100 = iyi uyum, 0 = kötü uyum) ---
    tax_compliance = 100.0

    mismatch_total = _safe_float(cons.get("beyan_tahakkuk_mismatch_total"))
    mismatch_over_100 = int(cons.get("beyan_tahakkuk_mismatch_over_100") or 0)
    missing_forms = int(cons.get("missing_beyan_count") or 0) + int(cons.get("missing_tahakkuk_count") or 0)  # noqa
    coverage_rate = cons.get("tax_payment_coverage_rate_verified")
    if coverage_rate is None:
        coverage_rate = cons.get("tax_payment_coverage_rate")
    bank_ok = bool(cons.get("bank_data_sufficient"))
    verifiable = int(cons.get("verifiable_obligation_count") or 0)

    # Banka verisi dönem açısından yeterli değilse coverage_rate cezası uygulamayız.

    # Beyan–tahakkuk tutarlılığı: fark büyüdükçe uyum düşer
    tax_compliance -= min(40.0, mismatch_total / 1000.0 * 5.0)
    tax_compliance -= mismatch_over_100 * 5.0
    tax_compliance -= missing_forms * 10.0

    # Ödeme kapsamı: sadece "eksik ödeme" sinyalinde düşür.
    # coverage_rate > 1 çoğu zaman dönem kayması / sınıflandırma genişliği nedeniyle olabilir.
    if bank_ok and verifiable > 0 and coverage_rate is not None and coverage_rate < 0.95:
        tax_compliance -= 20.0

    tax_compliance = _clamp(tax_compliance)

    # KURGAN harmanı risk üzerinden yapılır (0 iyi, 100 kötü)
    tax_risk = 100.0 - tax_compliance

    # --- E-defter skoru ---
    total_lines = int(edefter.get("total_lines") or 0)
    kdv_ratio = _safe_float(edefter.get("kdv_line_ratio"))
    fx_lines = int(edefter.get("fx_lines") or 0)
    inflation_lines = int(edefter.get("inflation_lines") or 0)

    if total_lines == 0:
        edefter_score = 90.0  # veri yok → yüksek risk
    else:
        edefter_score = 30.0
        if kdv_ratio < 0.02:
            edefter_score += 20.0  # KDV ile ilgili satır oranı çok düşük
        if fx_lines > 0 and inflation_lines == 0:
            edefter_score += 20.0  # döviz var ama enflasyon/düzeltme izi yok
        if total_lines > 20000:
            edefter_score += 10.0  # çok büyük yevmiye → karmaşıklık

    edefter_score = _clamp(edefter_score)

    # --- SMİYB riski (sadece sayısal pattern) ---
    b_kdv = beyan.get("per_type", {}).get("KDV", {}).get("summary", {})
    b_kdv2 = beyan.get("per_type", {}).get("KDV2", {}).get("summary", {})
    kdv_matrah = _safe_float(b_kdv.get("matrah_toplami_sum"))
    kdv2_matrah = _safe_float(b_kdv2.get("matrah_sum"))
    pos_inflows = _safe_float(banka.get("pos_inflows"))
    receivables = _safe_float(mizan.get("receivables"))

    smiyb_score = 25.0
    if kdv_matrah > 0:
        ratio_kdv2 = kdv2_matrah / kdv_matrah
        if ratio_kdv2 > 0.1:
            smiyb_score += min(30.0, (ratio_kdv2 - 0.1) * 100.0)  # 0.4+ seviyede ekstra puan

    approx_turnover = kdv_matrah
    if approx_turnover > 0 and pos_inflows > approx_turnover * 1.2:
        smiyb_score += 20.0  # POS cirosu beyana göre çok yüksek

    if receivables > approx_turnover * 1.5:
        smiyb_score += 10.0  # alacaklar satışa göre çok yüksek

    smiyb_score = _clamp(smiyb_score)

    # --- Radar / yapısal risk ---
    total_current_assets = _safe_float(mizan.get("total_current_assets"))
    short_term_liab = _safe_float(mizan.get("short_term_liabilities"))
    equity_total = _safe_float(mizan.get("equity_total"))

    radar_score = 30.0
    if total_current_assets and short_term_liab:
        current_ratio = total_current_assets / short_term_liab
        if current_ratio < 1.0:
            radar_score += 25.0
        elif current_ratio < 1.2:
            radar_score += 15.0
        elif current_ratio < 1.5:
            radar_score += 5.0

    if equity_total <= 0:
        radar_score += 20.0  # negatif veya çok düşük özkaynak

    radar_score = _clamp(radar_score)

    # --- Enflasyon / kur risk skoru (kabaca, hukuki görüş değil) ---
    fx_lines = int(edefter.get("fx_lines") or 0)
    inflation_lines = int(edefter.get("inflation_lines") or 0)
    fx_exposed = fx_lines > 0

    inflation_score = 30.0
    if fx_exposed and inflation_lines == 0:
        inflation_score += 30.0  # döviz var, düzeltme izi yok
    elif fx_exposed and inflation_lines > 0:
        inflation_score += 10.0
    else:
        inflation_score += 5.0  # döviz yok → yine de genel enflasyon kontrolü gerekir

    inflation_score = _clamp(inflation_score)

    # --- Genel KURGAN skoru (blend) ---
    kurgan = (
        tax_risk * 0.3
        + smiyb_score * 0.25
        + radar_score * 0.2
        + edefter_score * 0.15
        + inflation_score * 0.1
    )

    kurgan = _clamp(kurgan)

    return RiskScores(
        kurgan_risk=kurgan,
        tax_compliance=tax_compliance,
        smiyb_risk=smiyb_score,
        radar_risk=radar_score,
        edefter_risk=edefter_score,
        inflation_risk=inflation_score,
    )


# ---------------------------------------------------------------------
# 8) KURAL TABANLI AI METİN KATI
# ---------------------------------------------------------------------
def build_ai_layer(
    smmm_id: str,
    client_id: str,
    period: str,
    metrics: Dict[str, Any],
    scores: RiskScores,
) -> Dict[str, Any]:
    """
    Dış LLM çağrısı yapmadan kural tabanlı Türkçe özet üretir.
    Hukuki sonuç cümlesi üretmez, sadece SMMM için checklist / tavsiye üretir.
    """
    cons = metrics.get("consistency", {})
    evidence = (cons.get("evidence_level") or "partial")
    mizan = metrics.get("mizan", {})
    edefter = metrics.get("edefter", {})

    def fmt_pct(x: Optional[Number]) -> str:
        if x is None:
            return "-"
        return f"{x*100:.1f}%"

    coverage_all = cons.get("tax_payment_coverage_rate")
    coverage_verified = cons.get("tax_payment_coverage_rate_verified")
    coverage_rate = coverage_verified if (evidence in ("verified","hybrid") and coverage_verified is not None) else coverage_all
    coverage_txt = fmt_pct(coverage_rate) if coverage_rate is not None else "-"
    evidence = cons.get("evidence_level") or ("verified" if cons.get("bank_data_sufficient") else "partial")
    bank_min = cons.get("bank_date_min")
    bank_max = cons.get("bank_date_max")
    exp_min = cons.get("bank_expected_min")
    exp_max = cons.get("bank_expected_max")


    summary_lines: List[str] = []

    # --- Banka ödeme eşleştirme: Unpaid VERIFIED vs PARTIAL ayrımı (AI anlatımı için) ---
    pm = cons.get("payment_matching", []) or []
    evidence = cons.get("evidence_level") or "partial"

    def _iso_date(s: str):
        try:
            return datetime.fromisoformat((s or "").strip()).date()
        except Exception:
            return None

    bank_min_d = _iso_date(cons.get("bank_date_min") or "")
    bank_max_d = _iso_date(cons.get("bank_date_max") or "")

    unpaid_verified = []
    unpaid_partial = []

    window_days = 10
    for o in pm:
        if not o.get("verifiable"):
            continue
        if (o.get("matched_amount") or 0) > 0:
            continue

        # window_lo/window_hi yoksa vade±window_days ile hesapla (robust)
        lo = _iso_date(o.get("window_lo") or "")
        hi = _iso_date(o.get("window_hi") or "")
        if lo is None or hi is None:
            vd = _iso_date(o.get("vade") or "")
            if vd:
                from datetime import timedelta
                lo = vd - timedelta(days=window_days)
                hi = vd + timedelta(days=window_days)

        # pencere tamamen banka aralığı içinde mi?
        if bank_min_d and bank_max_d and lo and hi and (bank_min_d <= lo) and (bank_max_d >= hi):
            unpaid_verified.append(o)
        else:
            unpaid_partial.append(o)

    summary_lines.append(
        f"{client_id} için {period} dönemi verileri (beyanname, tahakkuk, mizan, banka, e-defter) birlikte analiz edildi."
    )
    summary_lines.append(
        f"Kurgan toplam risk skoru: {scores.kurgan_risk:.1f} / 100 "
        f"(Vergi uyumu: {scores.tax_compliance:.1f}, SMİYB: {scores.smiyb_risk:.1f}, "
        f"Yapısal radar: {scores.radar_risk:.1f}, E-defter: {scores.edefter_risk:.1f}, Enflasyon: {scores.inflation_risk:.1f})."
    )
    if evidence == "verified" and coverage_rate is not None:
        summary_lines.append(
            f"Tahakkuk eden vergilerin banka hareketleri üzerinden ödeme kapsam oranı yaklaşık {coverage_txt} seviyesinde."
        )
    elif evidence == "hybrid" and coverage_rate is not None:
        thn_cnt = int(cons.get("thn_matched_obligation_count") or 0)
        ver_cnt = int(cons.get("verified_obligation_count") or 0)
        summary_lines.append(
            "Uyarı: Banka hareketleri bu dönemin vade penceresini tam kapsamıyor; "
            f"ancak THN üzerinden {thn_cnt} ödeme doğrulandı. "
            f"Mevcut banka aralığında tamamen kapsanan {ver_cnt} yükümlülük için ödeme kapsam oranı yaklaşık {coverage_txt}. "
            "Bu oran bilgi amaçlıdır; skora ceza uygulanmaz."
        )

    elif evidence == "partial" and coverage_rate is not None:
        summary_lines.append(
            "Uyarı: Banka hareketleri bu dönemin vade penceresini tam kapsamıyor "
            f"(mevcut: {bank_min} → {bank_max}, beklenen: {exp_min} → {exp_max}). "
            f"Bu nedenle ödeme kapsam oranı ({coverage_txt}) yalnızca bilgi amaçlıdır; skora ceza uygulanmaz."
        )


    # Unpaid VERIFIED ise (pencere tamamen kapsanıyor ama ödeme yok) bunu ayrıca özetle
    if unpaid_verified:
        ex = unpaid_verified[:3]
        ex_txt = ", ".join(f'{x.get("type")} {x.get("period")} vade={x.get("vade")} expected={x.get("expected")}' for x in ex)
        summary_lines.append(
            f"Not: Banka aralığında tamamen kapsanan {len(unpaid_verified)} yükümlülük için ödeme hareketi görünmedi (örnek: {ex_txt})."
        )
    # Checklist
    checklist: List[str] = []

    if unpaid_verified:
        checklist.append(
            f"Banka aralığında tamamen kapsanan yükümlülüklerde ödeme görünmeyen {len(unpaid_verified)} kalem var; farklı banka hesabı/şube/kanal, mahsup-parçalı ödeme veya gecikme ihtimalini kontrol edin."
        )
    if unpaid_partial:
        checklist.append(
            f"Banka aralığı vade penceresini kesen {len(unpaid_partial)} kalem var; ilgili aylara ait eksik banka CSV'leri geldikçe bu kalemler yeniden doğrulanmalıdır."
        )
    if _safe_float(cons.get("beyan_tahakkuk_mismatch_total")) > 0:
        checklist.append(
            "Beyanname ile tahakkuk tutarları arasındaki farkları (özellikle 100 TL üzeri olanları) tek tek kontrol edin."
        )
    if evidence == "verified" and coverage_rate is not None and (coverage_rate < 0.95 or coverage_rate > 1.05):
        checklist.append(
            "Banka hesap hareketlerinde vergi dairesi ödemeleri ile tahakkuk toplamlarını karşılaştırın; eksik veya fazla ödeme var mı?"
        )
    if _safe_float(mizan.get("equity_total")) <= 0:
        checklist.append(
            "Özkaynakların negatif veya çok zayıf olup olmadığını kontrol edin; sermaye tamamlama / güçlendirme ihtiyacını değerlendirin."
        )
    if int(edefter.get("fx_lines") or 0) > 0 and int(edefter.get("inflation_lines") or 0) == 0:
        checklist.append(
            "Dövizli işlemler için kur değerlemesi ve enflasyon muhasebesi kayıtlarının (varsa) doğru yapıldığını doğrulayın."
        )
    if not checklist:
        checklist.append(
            "Bu dönem için kritik bir alarm görünmüyor; yine de örnekleme yoluyla birkaç beyanname, banka hareketi ve yevmiye kaydını manuel kontrol edin."
        )

    advice_lines: List[str] = []
    advice_lines.append(
        "Bu çıktı, sayısal tutarlılık ve oran analizi yapar; hukuki nitelikte bir vergi görüşü değildir."
    )
    advice_lines.append(
        "Herhangi bir önemli fark veya yüksek risk görülen alan için, ilgili beyannameleri, tahakkuk fişlerini ve e-defter kayıtlarını resmi mevzuat çerçevesinde detaylı inceleyin."
    )
    advice_lines.append(
        "Özellikle enflasyon muhasebesi ve kur değerlemesi konularında, güncel Vergi Usul Kanunu düzenlemeleri ve Gelir İdaresi Başkanlığı özelgeleri esas alınmalıdır."
    )

    return {
        "summary": "\n".join(summary_lines),
        "checklist": "\n".join(f"- {item}" for item in checklist),
        "advice": "\n".join(advice_lines),
    }


# ---------------------------------------------------------------------
# 9) DIŞA AÇILAN ANA FONKSİYON
# ---------------------------------------------------------------------
def run_risk_model_v1(
    base_dir: str,
    smmm_id: str,
    client_id: str,
    period: str,
) -> Dict[str, Any]:
    """Run Lyntos Risk Model v1 for a given SMMM/client/period."""
    base_path = Path(base_dir)

    raw = load_all_for_client_period(
        base_dir=base_path,
        smmm_id=smmm_id,
        client_id=client_id,
        period=period,
    ) or {}

    # loader isimleri farklı olabilir; toleranslı ol
    beyan_list = raw.get("beyanname") or raw.get("beyan") or []
    thk_list = raw.get("tahakkuk") or raw.get("thk") or []
    banka_list = raw.get("banka") or []
    mizan_list = raw.get("mizan") or []
    edefter_list = raw.get("edefter") or []

    beyan_metrics = compute_beyanname_metrics(beyan_list)
    thk_metrics = compute_tahakkuk_metrics(thk_list)
    banka_metrics = compute_banka_metrics(banka_list)
    mizan_metrics = compute_mizan_metrics(mizan_list)
    edefter_metrics = compute_edefter_metrics(edefter_list)

    consistency_metrics = compute_consistency_metrics(beyan_metrics, thk_metrics, banka_metrics)

    metrics = {
        "beyanname": beyan_metrics,
        "tahakkuk": thk_metrics,
        "banka": banka_metrics,
        "mizan": mizan_metrics,
        "edefter": edefter_metrics,
        "consistency": consistency_metrics,
    }

    scores = compute_scores(metrics)
    ai_layer = build_ai_layer(smmm_id, client_id, period, metrics, scores)

    return {
        "ok": True,
        "version": "v1",
        "smmm_id": smmm_id,
        "client_id": client_id,
        "period": period,
        "metrics": metrics,
        "scores": asdict(scores),
        "ai": ai_layer,
    }

