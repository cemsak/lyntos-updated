from __future__ import annotations
import re

import json
from pathlib import Path
from typing import Any, Dict, List, Optional


def _canon_account_code(code) -> str:
    """
    Canonicalize account codes as strings WITHOUT losing precision.

    Policy:
    - If input is a STRING, keep it as-is (after whitespace cleanup and comma->dot),
      DO NOT trim trailing zeros. (e.g., '102.50' stays '102.50', '102.504' stays '102.504')
    - If input is a FLOAT, format safely to avoid artifacts, then trim trailing zeros.
    """
    import re as _re
    if code is None:
        return ""
    if isinstance(code, float):
        s = f"{code:.6f}"
        s = s.strip().replace(",", ".")
        s = _re.sub(r"\s+", "", s)
        if "." in s:
            s = s.rstrip("0").rstrip(".")
        return s

    # string / other inputs: preserve precision
    s = str(code)
    s = s.strip().replace(",", ".")
    s = _re.sub(r"\s+", "", s)
    return s
def _rekey_account_map(d):
    """
    Rekey a {account_code -> amount} dict using _canon_account_code and sum duplicates.
    """
    if not isinstance(d, dict):
        return d
    out = {}
    for k, v in d.items():
        kk = _canon_account_code(k)
        try:
            vv = float(v or 0.0)
        except Exception:
            vv = v
        if kk in out and isinstance(out[kk], (int, float)) and isinstance(vv, (int, float)):
            out[kk] = float(out[kk]) + float(vv)
        else:
            out[kk] = vv
    return out


def _extract_bank_102_by_subaccount(bank_metrics: dict) -> dict:
    """Return {'102.01': 123.0, ...} from banka_metrics['per_account_closing'] keys."""
    out = {}
    pac = (bank_metrics or {}).get("per_account_closing") or {}
    for k, v in (pac.items() if isinstance(pac, dict) else []):
        m = re.search(r"(102\.\d+)", str(k))
        if not m:
            continue
        code = m.group(1)
        out[code] = out.get(code, 0.0) + float(v or 0.0)
    return out

def _extract_mizan_102_by_subaccount(mizan_deep: dict) -> dict:
    """Return {'102.01': bal, ...} using mizan_deep['balances'] if present."""
    out = {}
    if not isinstance(mizan_deep, dict):
        return out
    balances = mizan_deep.get("balances") or {}
    if not isinstance(balances, dict):
        return out
    for code, bal in balances.items():
        m = re.search(r"^(102\.\d+)", str(code))
        if not m:
            continue
        out[m.group(1)] = out.get(m.group(1), 0.0) + float(bal or 0.0)
    return _rekey_account_map(out)
DEFAULT_CONFIG: Dict[str, Any] = {
    "tax_rates": {
        "kvk": 0.25,
        "kdv": {"1": 0.01, "10": 0.10, "20": 0.20},
    },
    "benchmarks": {
        "safe_gross_margin_by_sector": {
            "imalat": 0.07,
            "hizmet": 0.15,
        },
        "default_gross_margin": 0.03,
    },
    "thresholds": {
        "cash_to_sales": 0.05,
        "cash_to_assets": 0.10,
        "bank_min_balance_when_sales_gt": {"sales": 1_000_000.0, "bank_min": 5_000.0},
        "related_party_receivable_to_equity": 0.10,
        "thin_cap_debt_to_equity": 3.0,
        "opex_7xx_to_sales": 0.80,
        "recon_bank_vs_mizan": 0.10,
        "tolerance_beyan_mizan": 0.02,
    },
}


def _deep_update(base: Dict[str, Any], upd: Dict[str, Any]) -> Dict[str, Any]:
    for k, v in (upd or {}).items():
        if isinstance(v, dict) and isinstance(base.get(k), dict):
            _deep_update(base[k], v)
        else:
            base[k] = v
    return base


def safe_float(x: Any, default: float = 0.0) -> float:
    if x is None:
        return default
    if isinstance(x, (int, float)):
        return float(x)
    s = str(x).strip()
    if not s:
        return default
    s = s.replace("\u00a0", " ").replace(" ", "")
    if s.count(",") == 1 and s.count(".") >= 1 and s.rfind(",") > s.rfind("."):
        s = s.replace(".", "").replace(",", ".")
    elif s.count(",") >= 1 and s.count(".") == 1 and s.rfind(".") > s.rfind(","):
        s = s.replace(",", "")
    elif s.count(",") == 1 and s.count(".") == 0:
        s = s.replace(",", ".")
    try:
        return float(s)
    except Exception:
        return default


def period_to_months(period: str) -> List[str]:
    if not period:
        return []
    if "-Q" in period:
        y, q = period.split("-Q", 1)
        qn = int(q)
        start_month = (qn - 1) * 3 + 1
        return [f"{y}-{m:02d}" for m in range(start_month, start_month + 3)]
    if len(period) == 7 and period[4] == "-":
        return [period]
    return []


class ConfigLoader:
    def __init__(self, path: Optional[str | Path] = None, overrides: Optional[Dict[str, Any]] = None):
        self.path = Path(path) if path else None
        self.overrides = overrides or {}

    def load(self) -> Dict[str, Any]:
        cfg: Dict[str, Any] = json.loads(json.dumps(DEFAULT_CONFIG))
        if self.path and self.path.exists():
            loaded = json.loads(self.path.read_text(encoding="utf-8"))
            _deep_update(cfg, loaded)
        if self.overrides:
            _deep_update(cfg, self.overrides)
        return cfg


class AccountParser:
    @staticmethod
    def _balance_asset(debit: float, credit: float) -> float:
        return debit - credit

    @staticmethod
    def _balance_credit(debit: float, credit: float) -> float:
        return credit - debit

    def process_mizan(self, mizan_list: List[Dict[str, Any]]) -> Dict[str, Any]:
        balances: Dict[str, float] = {}

        cash_100 = bank_102 = 0.0
        receivables = payables = 0.0
        rp_recv = rp_pay = 0.0
        inventory = equity = total_assets = 0.0

        gross_sales = discounts_61x = 0.0
        cogs_62x = opex_63x = opex_7xx = 0.0

        for row in (mizan_list or []):
            code = str(row.get("hesap_kodu") or row.get("account_code") or row.get("code") or "").strip()
            if not code:
                continue

            debit = safe_float(row.get("bakiye_borc") or row.get("debit"))
            credit = safe_float(row.get("bakiye_alacak") or row.get("credit"))

            first = code[0]
            if first in ("1", "2"):
                bal = self._balance_asset(debit, credit)
            elif first in ("3", "4", "5", "6"):
                bal = self._balance_credit(debit, credit)
            elif first == "7":
                bal = self._balance_asset(debit, credit)
            else:
                bal = self._balance_asset(debit, credit)

            balances[code] = bal

            if first in ("1", "2"):
                total_assets += max(bal, 0.0)

            if code.startswith("100"):
                cash_100 += max(bal, 0.0)
            if code.startswith("102"):
                bank_102 += max(bal, 0.0)

            if code.startswith(("120", "121")):
                receivables += max(bal, 0.0)
            if code.startswith(("320", "321")):
                payables += max(bal, 0.0)

            if code.startswith(("131", "231")):
                rp_recv += max(bal, 0.0)
            if code.startswith(("331", "431")):
                rp_pay += max(bal, 0.0)

            if code.startswith("15"):
                inventory += max(bal, 0.0)

            if code.startswith("5"):
                equity += max(bal, 0.0)

            if code.startswith(("600", "601", "602")):
                gross_sales += max(bal, 0.0)

            if code.startswith("61"):
                discounts_61x += max(self._balance_asset(debit, credit), 0.0)

            if code.startswith("62"):
                cogs_62x += max(self._balance_asset(debit, credit), 0.0)

            if code.startswith("63"):
                opex_63x += max(self._balance_asset(debit, credit), 0.0)

            if code.startswith("7"):
                opex_7xx += max(self._balance_asset(debit, credit), 0.0)

        net_sales = max(gross_sales - discounts_61x, 0.0)
        gross_margin = None
        if net_sales > 0:
            gross_margin = (net_sales - cogs_62x) / net_sales

        groups = {
            "cash_100": cash_100,
            "bank_102": bank_102,
            "receivables_120_121": receivables,
            "payables_320_321": payables,
            "related_party_receivables_131_231": rp_recv,
            "related_party_payables_331_431": rp_pay,
            "inventory_15x": inventory,
            "equity_5xx": equity,
            "total_assets_1_2": total_assets,
            "gross_sales_600_601_602": gross_sales,
            "sales_discounts_61x": discounts_61x,
            "net_sales": net_sales,
            "cogs_62x": cogs_62x,
            "opex_63x": opex_63x,
            "opex_7xx": opex_7xx,
            "gross_margin": gross_margin,
        }

        return {"groups": groups, "balances": balances}


def extract_kdv_matrah_sum(beyan_metrics: Dict[str, Any], period: str) -> Optional[float]:
    if not beyan_metrics:
        return None

    months = set(period_to_months(period))
    per_type = beyan_metrics.get("per_type") or {}
    kdv = per_type.get("KDV") or per_type.get("KDV1") or {}
    per_period = kdv.get("per_period") or {}
    if not isinstance(per_period, dict):
        return None

    total = 0.0
    hit = 0
    for m, vals in per_period.items():
        if months and m not in months:
            continue
        if not isinstance(vals, dict):
            continue
        matrah = vals.get("matrah_toplami") or vals.get("matrah") or vals.get("tax_base")
        if matrah is None:
            continue
        total += safe_float(matrah, 0.0)
        hit += 1

    return total if hit > 0 else None


def extract_bank_closing_balance(bank_metrics: Dict[str, Any]) -> Optional[float]:
    if not bank_metrics:
        return None
    for key in ("closing_balance_calculated", "closing_balance", "ending_balance", "balance_end"):
        if key in bank_metrics and bank_metrics.get(key) is not None:
            return safe_float(bank_metrics.get(key), None)  # type: ignore[arg-type]
    opening = bank_metrics.get("opening_balance")
    net = bank_metrics.get("net_change") or bank_metrics.get("net_flow")
    if opening is not None and net is not None:
        return safe_float(opening) + safe_float(net)
    return None


class RiskAnalyzer:
    def __init__(self, config: Dict[str, Any]):
        self.cfg = config or DEFAULT_CONFIG
    def _add(
        self,
        risks: List[Dict[str, Any]],
        *,
        code: str,
        title: str,
        severity: str,
        description: str,
        value_found: Any = None,
        threshold: Any = None,
        evidence: Any = "derived",
        **extra: Any,
    ):
        rec = {
            "code": code,
            "title": title,
            "severity": severity,
            "description": description,
            "value_found": value_found,
            "threshold": threshold,
            "evidence": evidence,
        }
        if extra:
            rec.update(extra)
        risks.append(rec)

    def analyze(self, *, mizan_deep: Dict[str, Any], beyan_metrics: Dict[str, Any], bank_metrics: Dict[str, Any],
                period: str, sector: Optional[str] = None) -> Dict[str, Any]:
        risks: List[Dict[str, Any]] = []
        g = (mizan_deep or {}).get("groups") or {}

        cash = safe_float(g.get("cash_100"))
        bank = safe_float(g.get("bank_102"))
        equity = safe_float(g.get("equity_5xx"))
        total_assets = safe_float(g.get("total_assets_1_2"))
        net_sales = safe_float(g.get("net_sales"))
        gross_sales = safe_float(g.get("gross_sales_600_601_602"))
        cogs = safe_float(g.get("cogs_62x"))
        opex_7xx = safe_float(g.get("opex_7xx"))
        gross_margin = g.get("gross_margin")

        th = self.cfg.get("thresholds") or {}
        tol = float(th.get("tolerance_beyan_mizan", 0.02))

        # R-101 Kasa şişkinliği
        cash_to_sales_thr = net_sales * float(th.get("cash_to_sales", 0.05))
        cash_to_assets_thr = total_assets * float(th.get("cash_to_assets", 0.10))
        if cash > 0 and (cash > cash_to_sales_thr or cash > cash_to_assets_thr):
            self._add(
                risks,
                code="R-101",
                title="Kasa Şişkinliği / ADAT Riski",
                severity="HIGH" if cash > max(cash_to_sales_thr, cash_to_assets_thr) * 1.5 else "MEDIUM",
                description="100 Kasa bakiyesi eşikleri aşıyor (Net Satış %5 veya Varlık %10).",
                value_found=cash,
                threshold={"cash_to_sales": cash_to_sales_thr, "cash_to_assets": cash_to_assets_thr},
            )

        # R-102 Banka düşük
        rule = th.get("bank_min_balance_when_sales_gt") or {}
        sales_gt = float(rule.get("sales", 1_000_000.0))
        bank_min = float(rule.get("bank_min", 5_000.0))
        if net_sales >= sales_gt and bank < bank_min:
            self._add(
                risks,
                code="R-102",
                title="Banka Bakiyesi Düşüklüğü / Kayıtdışı Tahsilat Şüphesi",
                severity="HIGH",
                description="Net satış yüksekken 102 banka bakiyesi çok düşük.",
                value_found=bank,
                threshold=bank_min,
            )

        # R-201 / R-202 ilişkili taraf
        rp_recv = safe_float(g.get("related_party_receivables_131_231"))
        rp_pay = safe_float(g.get("related_party_payables_331_431"))
        if equity > 0 and rp_recv > equity * float(th.get("related_party_receivable_to_equity", 0.10)):
            self._add(
                risks,
                code="R-201",
                title="Ortaklardan Alacak Şişkinliği",
                severity="HIGH",
                description="131/231 bakiyesi özkaynağa göre yüksek.",
                value_found=rp_recv,
                threshold=equity * float(th.get("related_party_receivable_to_equity", 0.10)),
            )
        if equity > 0 and rp_pay > equity * float(th.get("thin_cap_debt_to_equity", 3.0)):
            self._add(
                risks,
                code="R-202",
                title="Örtülü Sermaye (KVK m.12) İhtimali",
                severity="HIGH",
                description="331/431 bakiyesi özkaynağın 3 katı eşiğini aşıyor.",
                value_found=rp_pay,
                threshold=equity * float(th.get("thin_cap_debt_to_equity", 3.0)),
            )

        # R-301 Brüt marj
        sector_bm = (self.cfg.get("benchmarks") or {}).get("safe_gross_margin_by_sector") or {}
        default_gm = float((self.cfg.get("benchmarks") or {}).get("default_gross_margin", 0.03))
        gm_thr = float(sector_bm.get((sector or "").lower(), default_gm))
        if net_sales > 0 and gross_margin is not None and float(gross_margin) < gm_thr:
            self._add(
                risks,
                code="R-301",
                title="Düşük Brüt Kâr Marjı",
                severity="HIGH",
                description="Brüt kâr marjı eşik altında.",
                value_found={"gross_margin": float(gross_margin), "net_sales": net_sales, "cogs": cogs},
                threshold=gm_thr,
            )

        # R-302 7xx/satış
        if net_sales > 0 and (opex_7xx / net_sales) > float(th.get("opex_7xx_to_sales", 0.80)):
            self._add(
                risks,
                code="R-302",
                title="Aşırı Faaliyet Giderleri (7xx)/Satış",
                severity="HIGH",
                description="7xx giderleri / Net satışlar oranı yüksek.",
                value_found={"opex_7xx": opex_7xx, "net_sales": net_sales, "ratio": opex_7xx / net_sales},
                threshold=float(th.get("opex_7xx_to_sales", 0.80)),
            )
        # R-401 banka ↔ 102 (hesap bazlı mutabakat) [VDK-grade]
        bq = bank_metrics or {}
        balance_ok = bool(bq.get("balance_consistency_ok"))
        gap_ratio = bq.get("balance_gap_ratio")
        accounts_ok_ratio = bq.get("accounts_ok_ratio")

        bank102 = _extract_bank_102_by_subaccount(bank_metrics)
        miz102 = _extract_mizan_102_by_subaccount(mizan_deep)

        miz102 = _rekey_account_map(miz102)
        bank102 = _rekey_account_map(bank102)
        # Eğer mizan balances yoksa, eski total yaklaşımı yedekte tut
        if not miz102:
            bank_close = extract_bank_closing_balance(bank_metrics)
            if bank_close is not None and balance_ok:
                diff = abs(bank_close - bank)
                rel = diff / max(1.0, max(bank_close, bank))
                if rel > float(th.get("recon_bank_vs_mizan", 0.10)):
                    self._add(
                        risks,
                        code="R-401",
                        title="Banka - Mizan (102) Mutabakat Uyumsuzluğu",
                        severity="HIGH" if rel > 0.25 else "MEDIUM",
                        description="CSV kapanış bakiyesi ile 102 bakiye farkı yüksek.",
                        value_found={"bank_close": bank_close, "mizan_102": bank, "diff": diff, "rel": rel},
                        threshold=float(th.get("recon_bank_vs_mizan", 0.10)),
                        evidence="bank+ledger",
                    )
            if bank_close is not None and not balance_ok:
                self._add(
                    risks,
                    code="R-401Q",
                    title="Banka CSV Kalite Sorunu / Çakışan Ekstre İhtimali",
                    severity="MEDIUM" if float(gap_ratio or 0.0) > 0.10 else "LOW",
                    description="Banka hareketleri ile bakiye zinciri tutarlı değil. R-401 değerlendirmesi baskılandı.",
                    value_found={"bank_close": bank_close, "accounts_ok_ratio": accounts_ok_ratio, "balance_gap_ratio": gap_ratio},
                    threshold={"accounts_ok_ratio_min": 0.80, "balance_gap_ratio_max": 0.02},
                    evidence="bank",
                )
        else:
            # 1) Mizanda var, bankada yok
            missing_in_bank = {k: v for k, v in miz102.items() if k not in bank102 and abs(v) > 1.0}
            if missing_in_bank:
                max_missing = max((abs(float(v or 0.0)) for v in missing_in_bank.values()), default=0.0)

                sev_missing = 'HIGH' if max_missing >= 100000.0 else ('MEDIUM' if max_missing >= 10000.0 else 'LOW')

                self._add(
                    risks,
                    code="R-401A",
                    title="Mizan 102 Alt Hesap Var, Banka Ekstresi Yok",

                    severity=sev_missing,
                    description="Mizanda görünen bazı 102.xx alt hesaplar için banka ekstresi verisi bulunamadı (eksik ekstre veya banka dışı alt hesap olabilir).",
                    value_found={"missing_102": missing_in_bank},
                    threshold={"min_abs_balance": 1.0},
                    evidence="ledger",
                    evidence_details={"note": "Bu durum tek başına 'usulsüzlük' değildir. 102.xx alt hesabın hangi banka/hesap olduğuna göre ekstre yüklenmeli veya alt hesap sınıflaması gözden geçirilmeli."},
                )

            # 2) Bankada var, mizanda yok
            missing_in_mizan = {k: v for k, v in bank102.items() if k not in miz102 and abs(v) > 1.0}
            if missing_in_mizan:
                self._add(
                    risks,
                    code="R-401B",
                    title="Banka Ekstresi Var, Mizanda 102 Alt Hesap Yok",
                    severity="MEDIUM",
                    description="Banka ekstresi verisi bulunan bazı 102.xx alt hesaplar mizanda görünmüyor (mizan export kapsamı veya hesap sınıflaması kontrol edilmeli).",
                    value_found={"missing_102": missing_in_mizan},
                    threshold={"min_abs_balance": 1.0},
                    evidence="bank",
                    evidence_details={"note": "Detay mizan/alt hesap export'unu ve 102 hesap planını kontrol edin."},
                )

            # 3) Ortak hesaplarda bakiye farkı
            tol = float(th.get("recon_bank_vs_mizan", 0.10))
            diffs = {}
            worst = None
            for k in set(bank102.keys()) & set(miz102.keys()):
                bclose = float(bank102.get(k) or 0.0)
                mbal = float(miz102.get(k) or 0.0)
                diff = mbal - bclose
                rel = abs(diff) / max(1.0, max(abs(mbal), abs(bclose)))
                if rel > tol and abs(diff) >= 10000.0:
                    diffs[k] = {"bank_close": bclose, "mizan_102": mbal, "diff": diff, "rel": rel}
                    if (worst is None) or (rel > worst[0]):
                        worst = (rel, k)

            if diffs:
                sev = "HIGH" if (worst and worst[0] > 0.25) else "MEDIUM"
                self._add(
                    risks,
                    code="R-401C",
                    title="Banka - Mizan (102) Alt Hesap Mutabakat Farkı",
                    severity=sev,
                    description="Bazı 102.xx alt hesaplarda banka kapanışı ile mizan bakiyesi arasında tolerans üstü fark var.",
                    value_found={"diffs": diffs, "worst": (worst[1] if worst else None)},
                    threshold={"tolerance": tol},
                    evidence="bank+ledger",
                    evidence_details={"note": "Hesap bazlı inceleme önerilir (vadeli/bloke hesaplar, gün sonu kesiti, muhasebe fiş tarihleri vb.)."},
                )
        # R-501 KDV matrah ↔ satış
        kdv_matrah = extract_kdv_matrah_sum(beyan_metrics, period)
        if kdv_matrah is not None and gross_sales > 0:
            diff = abs(kdv_matrah - gross_sales)
            rel = diff / max(1.0, gross_sales)
            if rel > tol:
                self._add(
                    risks,
                    code="R-501",
                    title="KDV Matrahı - Satışlar Uyumsuzluğu",
                    severity="HIGH" if rel > 0.10 else "MEDIUM",
                    description="Beyanname KDV matrahı ile 600/601/602 satışları arasında sapma var.",
                    value_found={
                        "kdv_matrah_sum": kdv_matrah,
                        "mizan_sales": gross_sales,
                        "diff": diff,
                        "diff_ratio": rel,
                        "diff_ratio_pct": rel * 100.0,
                    },
                    threshold={"rel_tolerance": tol, "severity_high_rel": 0.10},
                    evidence="declaration+ledger",
                    evidence_details={
                        "comparison": "KDV Matrahı (beyanname) ↔ Brüt Satışlar (mizan)",
                        "mizan_sales_accounts": ["600", "601", "602"],
                        "period": period,
                        "note": "Otomatik mutabakat sinyali; kesin hüküm değildir. Kaynak kayıtlar (yevmiye/fatura) ile doğrulama önerilir.",
                    },
                    derived={
                        "diff_amount": diff,
                        "diff_ratio": rel,
                        "diff_ratio_pct": rel * 100.0,
                    },
                )


        sev_counts: Dict[str, int] = {}
        for r in risks:
            sev = r.get("severity") or "UNKNOWN"
            sev_counts[sev] = sev_counts.get(sev, 0) + 1

        return {
            "period": period,
            "sector": sector,
            "derived": {
                "net_sales": net_sales,
                "gross_sales": gross_sales,
                "gross_margin": gross_margin,
                "cash_100": cash,
                "bank_102": bank,
                "equity_5xx": equity,
                "total_assets_1_2": total_assets,
                "rp_recv": rp_recv,
                "rp_pay": rp_pay,
            },
            "risks": risks,
            "risk_count": len(risks),
            "severity_counts": sev_counts,
            "config_snapshot": {"thresholds": th, "benchmarks": (self.cfg.get("benchmarks") or {})},
        }
