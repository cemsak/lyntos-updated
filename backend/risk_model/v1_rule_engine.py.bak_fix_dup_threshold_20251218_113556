from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, List, Optional


DEFAULT_CONFIG: Dict[str, Any] = {
    "tax_rates": {
        "kvk": 0.25,
        "kdv": {"1": 0.01, "10": 0.10, "20": 0.20},
    },
    "benchmarks": {
        "safe_gross_margin_by_sector": {
            "imalat": 0.07,
            "hizmet": 0.15,
        },
        "default_gross_margin": 0.03,
    },
    "thresholds": {
        "cash_to_sales": 0.05,
        "cash_to_assets": 0.10,
        "bank_min_balance_when_sales_gt": {"sales": 1_000_000.0, "bank_min": 5_000.0},
        "related_party_receivable_to_equity": 0.10,
        "thin_cap_debt_to_equity": 3.0,
        "opex_7xx_to_sales": 0.80,
        "recon_bank_vs_mizan": 0.10,
        "tolerance_beyan_mizan": 0.02,
    },
}


def _deep_update(base: Dict[str, Any], upd: Dict[str, Any]) -> Dict[str, Any]:
    for k, v in (upd or {}).items():
        if isinstance(v, dict) and isinstance(base.get(k), dict):
            _deep_update(base[k], v)
        else:
            base[k] = v
    return base


def safe_float(x: Any, default: float = 0.0) -> float:
    if x is None:
        return default
    if isinstance(x, (int, float)):
        return float(x)
    s = str(x).strip()
    if not s:
        return default
    s = s.replace("\u00a0", " ").replace(" ", "")
    if s.count(",") == 1 and s.count(".") >= 1 and s.rfind(",") > s.rfind("."):
        s = s.replace(".", "").replace(",", ".")
    elif s.count(",") >= 1 and s.count(".") == 1 and s.rfind(".") > s.rfind(","):
        s = s.replace(",", "")
    elif s.count(",") == 1 and s.count(".") == 0:
        s = s.replace(",", ".")
    try:
        return float(s)
    except Exception:
        return default


def period_to_months(period: str) -> List[str]:
    if not period:
        return []
    if "-Q" in period:
        y, q = period.split("-Q", 1)
        qn = int(q)
        start_month = (qn - 1) * 3 + 1
        return [f"{y}-{m:02d}" for m in range(start_month, start_month + 3)]
    if len(period) == 7 and period[4] == "-":
        return [period]
    return []


class ConfigLoader:
    def __init__(self, path: Optional[str | Path] = None, overrides: Optional[Dict[str, Any]] = None):
        self.path = Path(path) if path else None
        self.overrides = overrides or {}

    def load(self) -> Dict[str, Any]:
        cfg: Dict[str, Any] = json.loads(json.dumps(DEFAULT_CONFIG))
        if self.path and self.path.exists():
            loaded = json.loads(self.path.read_text(encoding="utf-8"))
            _deep_update(cfg, loaded)
        if self.overrides:
            _deep_update(cfg, self.overrides)
        return cfg


class AccountParser:
    @staticmethod
    def _balance_asset(debit: float, credit: float) -> float:
        return debit - credit

    @staticmethod
    def _balance_credit(debit: float, credit: float) -> float:
        return credit - debit

    def process_mizan(self, mizan_list: List[Dict[str, Any]]) -> Dict[str, Any]:
        balances: Dict[str, float] = {}

        cash_100 = bank_102 = 0.0
        receivables = payables = 0.0
        rp_recv = rp_pay = 0.0
        inventory = equity = total_assets = 0.0

        gross_sales = discounts_61x = 0.0
        cogs_62x = opex_63x = opex_7xx = 0.0

        for row in (mizan_list or []):
            code = str(row.get("hesap_kodu") or row.get("account_code") or row.get("code") or "").strip()
            if not code:
                continue

            debit = safe_float(row.get("bakiye_borc") or row.get("debit"))
            credit = safe_float(row.get("bakiye_alacak") or row.get("credit"))

            first = code[0]
            if first in ("1", "2"):
                bal = self._balance_asset(debit, credit)
            elif first in ("3", "4", "5", "6"):
                bal = self._balance_credit(debit, credit)
            elif first == "7":
                bal = self._balance_asset(debit, credit)
            else:
                bal = self._balance_asset(debit, credit)

            balances[code] = bal

            if first in ("1", "2"):
                total_assets += max(bal, 0.0)

            if code.startswith("100"):
                cash_100 += max(bal, 0.0)
            if code.startswith("102"):
                bank_102 += max(bal, 0.0)

            if code.startswith(("120", "121")):
                receivables += max(bal, 0.0)
            if code.startswith(("320", "321")):
                payables += max(bal, 0.0)

            if code.startswith(("131", "231")):
                rp_recv += max(bal, 0.0)
            if code.startswith(("331", "431")):
                rp_pay += max(bal, 0.0)

            if code.startswith("15"):
                inventory += max(bal, 0.0)

            if code.startswith("5"):
                equity += max(bal, 0.0)

            if code.startswith(("600", "601", "602")):
                gross_sales += max(bal, 0.0)

            if code.startswith("61"):
                discounts_61x += max(self._balance_asset(debit, credit), 0.0)

            if code.startswith("62"):
                cogs_62x += max(self._balance_asset(debit, credit), 0.0)

            if code.startswith("63"):
                opex_63x += max(self._balance_asset(debit, credit), 0.0)

            if code.startswith("7"):
                opex_7xx += max(self._balance_asset(debit, credit), 0.0)

        net_sales = max(gross_sales - discounts_61x, 0.0)
        gross_margin = None
        if net_sales > 0:
            gross_margin = (net_sales - cogs_62x) / net_sales

        groups = {
            "cash_100": cash_100,
            "bank_102": bank_102,
            "receivables_120_121": receivables,
            "payables_320_321": payables,
            "related_party_receivables_131_231": rp_recv,
            "related_party_payables_331_431": rp_pay,
            "inventory_15x": inventory,
            "equity_5xx": equity,
            "total_assets_1_2": total_assets,
            "gross_sales_600_601_602": gross_sales,
            "sales_discounts_61x": discounts_61x,
            "net_sales": net_sales,
            "cogs_62x": cogs_62x,
            "opex_63x": opex_63x,
            "opex_7xx": opex_7xx,
            "gross_margin": gross_margin,
        }

        return {"groups": groups, "balances": balances}


def extract_kdv_matrah_sum(beyan_metrics: Dict[str, Any], period: str) -> Optional[float]:
    if not beyan_metrics:
        return None

    months = set(period_to_months(period))
    per_type = beyan_metrics.get("per_type") or {}
    kdv = per_type.get("KDV") or per_type.get("KDV1") or {}
    per_period = kdv.get("per_period") or {}
    if not isinstance(per_period, dict):
        return None

    total = 0.0
    hit = 0
    for m, vals in per_period.items():
        if months and m not in months:
            continue
        if not isinstance(vals, dict):
            continue
        matrah = vals.get("matrah_toplami") or vals.get("matrah") or vals.get("tax_base")
        if matrah is None:
            continue
        total += safe_float(matrah, 0.0)
        hit += 1

    return total if hit > 0 else None


def extract_bank_closing_balance(bank_metrics: Dict[str, Any]) -> Optional[float]:
    if not bank_metrics:
        return None
    for key in ("closing_balance_calculated", "closing_balance", "ending_balance", "balance_end"):
        if key in bank_metrics and bank_metrics.get(key) is not None:
            return safe_float(bank_metrics.get(key), None)  # type: ignore[arg-type]
    opening = bank_metrics.get("opening_balance")
    net = bank_metrics.get("net_change") or bank_metrics.get("net_flow")
    if opening is not None and net is not None:
        return safe_float(opening) + safe_float(net)
    return None


class RiskAnalyzer:
    def __init__(self, config: Dict[str, Any]):
        self.cfg = config or DEFAULT_CONFIG

    def _add(self, risks: List[Dict[str, Any]], *, code: str, title: str, severity: str,
             description: str, value_found: Any = None, threshold: Any = None, evidence: str = "derived"):
        risks.append({
            "code": code,
            "title": title,
            "severity": severity,
            "description": description,
            "value_found": value_found,
            "threshold": threshold,
            "evidence": evidence,
        })

    def analyze(self, *, mizan_deep: Dict[str, Any], beyan_metrics: Dict[str, Any], bank_metrics: Dict[str, Any],
                period: str, sector: Optional[str] = None) -> Dict[str, Any]:
        risks: List[Dict[str, Any]] = []
        g = (mizan_deep or {}).get("groups") or {}

        cash = safe_float(g.get("cash_100"))
        bank = safe_float(g.get("bank_102"))
        equity = safe_float(g.get("equity_5xx"))
        total_assets = safe_float(g.get("total_assets_1_2"))
        net_sales = safe_float(g.get("net_sales"))
        gross_sales = safe_float(g.get("gross_sales_600_601_602"))
        cogs = safe_float(g.get("cogs_62x"))
        opex_7xx = safe_float(g.get("opex_7xx"))
        gross_margin = g.get("gross_margin")

        th = self.cfg.get("thresholds") or {}
        tol = float(th.get("tolerance_beyan_mizan", 0.02))

        # R-101 Kasa şişkinliği
        cash_to_sales_thr = net_sales * float(th.get("cash_to_sales", 0.05))
        cash_to_assets_thr = total_assets * float(th.get("cash_to_assets", 0.10))
        if cash > 0 and (cash > cash_to_sales_thr or cash > cash_to_assets_thr):
            self._add(
                risks,
                code="R-101",
                title="Kasa Şişkinliği / ADAT Riski",
                severity="HIGH" if cash > max(cash_to_sales_thr, cash_to_assets_thr) * 1.5 else "MEDIUM",
                description="100 Kasa bakiyesi eşikleri aşıyor (Net Satış %5 veya Varlık %10).",
                value_found=cash,
                threshold={"cash_to_sales": cash_to_sales_thr, "cash_to_assets": cash_to_assets_thr},
            )

        # R-102 Banka düşük
        rule = th.get("bank_min_balance_when_sales_gt") or {}
        sales_gt = float(rule.get("sales", 1_000_000.0))
        bank_min = float(rule.get("bank_min", 5_000.0))
        if net_sales >= sales_gt and bank < bank_min:
            self._add(
                risks,
                code="R-102",
                title="Banka Bakiyesi Düşüklüğü / Kayıtdışı Tahsilat Şüphesi",
                severity="HIGH",
                description="Net satış yüksekken 102 banka bakiyesi çok düşük.",
                value_found=bank,
                threshold=bank_min,
            )

        # R-201 / R-202 ilişkili taraf
        rp_recv = safe_float(g.get("related_party_receivables_131_231"))
        rp_pay = safe_float(g.get("related_party_payables_331_431"))
        if equity > 0 and rp_recv > equity * float(th.get("related_party_receivable_to_equity", 0.10)):
            self._add(
                risks,
                code="R-201",
                title="Ortaklardan Alacak Şişkinliği",
                severity="HIGH",
                description="131/231 bakiyesi özkaynağa göre yüksek.",
                value_found=rp_recv,
                threshold=equity * float(th.get("related_party_receivable_to_equity", 0.10)),
            )
        if equity > 0 and rp_pay > equity * float(th.get("thin_cap_debt_to_equity", 3.0)):
            self._add(
                risks,
                code="R-202",
                title="Örtülü Sermaye (KVK m.12) İhtimali",
                severity="HIGH",
                description="331/431 bakiyesi özkaynağın 3 katı eşiğini aşıyor.",
                value_found=rp_pay,
                threshold=equity * float(th.get("thin_cap_debt_to_equity", 3.0)),
            )

        # R-301 Brüt marj
        sector_bm = (self.cfg.get("benchmarks") or {}).get("safe_gross_margin_by_sector") or {}
        default_gm = float((self.cfg.get("benchmarks") or {}).get("default_gross_margin", 0.03))
        gm_thr = float(sector_bm.get((sector or "").lower(), default_gm))
        if net_sales > 0 and gross_margin is not None and float(gross_margin) < gm_thr:
            self._add(
                risks,
                code="R-301",
                title="Düşük Brüt Kâr Marjı",
                severity="HIGH",
                description="Brüt kâr marjı eşik altında.",
                value_found={"gross_margin": float(gross_margin), "net_sales": net_sales, "cogs": cogs},
                threshold=gm_thr,
            )

        # R-302 7xx/satış
        if net_sales > 0 and (opex_7xx / net_sales) > float(th.get("opex_7xx_to_sales", 0.80)):
            self._add(
                risks,
                code="R-302",
                title="Aşırı Faaliyet Giderleri (7xx)/Satış",
                severity="HIGH",
                description="7xx giderleri / Net satışlar oranı yüksek.",
                value_found={"opex_7xx": opex_7xx, "net_sales": net_sales, "ratio": opex_7xx / net_sales},
                threshold=float(th.get("opex_7xx_to_sales", 0.80)),
            )

        # R-401 banka ↔ 102 (opsiyonel)
        bank_close = extract_bank_closing_balance(bank_metrics)
        if bank_close is not None:
            diff = abs(bank_close - bank)
            rel = diff / max(1.0, max(bank_close, bank))
            if rel > float(th.get("recon_bank_vs_mizan", 0.10)):
                self._add(
                    risks,
                    code="R-401",
                    title="Banka - Mizan (102) Mutabakat Uyumsuzluğu",
                    severity="HIGH" if rel > 0.25 else "MEDIUM",
                    description="CSV kapanış bakiyesi ile 102 bakiye farkı yüksek.",
                    value_found={"bank_close": bank_close, "mizan_102": bank, "diff": diff, "rel": rel},
                    threshold=float(th.get("recon_bank_vs_mizan", 0.10)),
                    evidence="bank+ledger",
                )

        # R-501 KDV matrah ↔ satış
        kdv_matrah = extract_kdv_matrah_sum(beyan_metrics, period)
        if kdv_matrah is not None and gross_sales > 0:
            diff = abs(kdv_matrah - gross_sales)
            rel = diff / max(1.0, gross_sales)
            if rel > tol:
                self._add(
                    risks,
                    code="R-501",
                    title="KDV Matrahı - Satışlar Uyumsuzluğu",
                    severity="HIGH" if rel > 0.10 else "MEDIUM",
                    description="Beyanname KDV matrahı ile 600/601/602 satışları arasında sapma var.",
                    value_found={"kdv_matrah_sum": kdv_matrah, "mizan_sales": gross_sales, "diff": diff, "rel": rel, "rel_pct": rel * 100.0},
                    threshold={"rel_tolerance": tol, "severity_high_rel": 0.10},
                    evidence={
                        "comparison": "KDV Matrahı (beyanname) ↔ Brüt Satışlar (mizan)",
                        "mizan_sales_accounts": ["600", "601", "602"],
                        "period": period,
                        "note": "Bu bulgu otomatik mutabakat sinyalidir; kesin hüküm değildir. Kaynak kayıtlar (yevmiye/fatura) ile doğrulama önerilir.",
                    },
                    derived={
                        "diff_amount": diff,
                        "diff_ratio": rel,
                        "diff_ratio_pct": rel * 100.0,
                    },
                    threshold={"tolerance": tol},
                    evidence="declaration+ledger",
                )

        sev_counts: Dict[str, int] = {}
        for r in risks:
            sev = r.get("severity") or "UNKNOWN"
            sev_counts[sev] = sev_counts.get(sev, 0) + 1

        return {
            "period": period,
            "sector": sector,
            "derived": {
                "net_sales": net_sales,
                "gross_sales": gross_sales,
                "gross_margin": gross_margin,
                "cash_100": cash,
                "bank_102": bank,
                "equity_5xx": equity,
                "total_assets_1_2": total_assets,
                "rp_recv": rp_recv,
                "rp_pay": rp_pay,
            },
            "risks": risks,
            "risk_count": len(risks),
            "severity_counts": sev_counts,
            "config_snapshot": {"thresholds": th, "benchmarks": (self.cfg.get("benchmarks") or {})},
        }
