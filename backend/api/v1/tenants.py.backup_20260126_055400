"""
Tenant & Taxpayer Management API
Lists taxpayers (mükellef) and periods (dönem) for SMMM offices

LYNTOS Enterprise - Multi-tenant SMMM Platform

Sprint 4: Now uses real database data instead of hardcoded demo data
Sprint 7: Added taxpayer CRUD operations (create, delete)
"""

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, Field
from typing import List, Optional
from middleware.auth import verify_token
from pathlib import Path
import sqlite3
import uuid
from datetime import datetime

router = APIRouter(prefix="/tenants", tags=["tenants"])

# Database path
DB_PATH = Path(__file__).parent.parent.parent / "database" / "lyntos.db"
DATA_DIR = Path(__file__).parent.parent.parent / "data"


def get_db():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def _get_client_folder_name(cursor, client_id: str) -> Optional[str]:
    """Get disk folder name for client (from clients.folder_name column)"""
    cursor.execute("SELECT folder_name FROM clients WHERE id = ?", (client_id,))
    row = cursor.fetchone()
    if row and row["folder_name"]:
        return row["folder_name"]
    return None


def _find_period_folder(smmm_id: str, client_id: str, period: str, cursor) -> Optional[Path]:
    """Find period folder on disk (handles variations like 2025-Q1__SMOKETEST...)"""
    folder_name = _get_client_folder_name(cursor, client_id)
    disk_client_id = folder_name if folder_name else client_id

    client_dir = DATA_DIR / "luca" / smmm_id / disk_client_id
    if not client_dir.exists():
        client_dir = DATA_DIR / "luca" / smmm_id / client_id
        if not client_dir.exists():
            return None

    # Exact match first
    exact_path = client_dir / period
    if exact_path.exists():
        return exact_path

    # Try with suffix variations
    for folder in client_dir.iterdir():
        if folder.is_dir() and folder.name.startswith(period):
            return folder
    return None


def _check_disk_data(smmm_id: str, client_id: str, period_id: str, cursor) -> dict:
    """Check disk for data files when database is empty"""
    result = {
        "mizan": False,
        "mizan_count": 0,
        "beyanname": False,
        "beyanname_count": 0,
        "banka": False,
        "banka_count": 0,
        "edefter": False,
        "edefter_count": 0,
        "tahakkuk": False,
        "tahakkuk_count": 0,
    }

    period_dir = _find_period_folder(smmm_id, client_id, period_id, cursor)
    if not period_dir:
        return result

    # Check mizan.csv
    if (period_dir / "mizan.csv").exists():
        result["mizan"] = True
        result["mizan_count"] = 1

    # Check beyanname folder
    beyanname_dir = period_dir / "beyanname"
    if beyanname_dir.exists():
        files = list(beyanname_dir.glob("*.pdf")) + list(beyanname_dir.glob("*.xml"))
        if files:
            result["beyanname"] = True
            result["beyanname_count"] = len(files)

    # Check tahakkuk folder
    tahakkuk_dir = period_dir / "tahakkuk"
    if tahakkuk_dir.exists():
        files = list(tahakkuk_dir.glob("*.pdf"))
        if files:
            result["tahakkuk"] = True
            result["tahakkuk_count"] = len(files)

    # Check banka folder
    banka_dir = period_dir / "banka"
    if banka_dir.exists():
        files = list(banka_dir.glob("*.pdf")) + list(banka_dir.glob("*.xlsx")) + list(banka_dir.glob("*.csv"))
        if files:
            result["banka"] = True
            result["banka_count"] = len(files)

    # Check e-defter folder or _raw
    edefter_dir = period_dir / "e-defter"
    raw_dir = period_dir / "_raw"
    if edefter_dir.exists():
        files = list(edefter_dir.glob("*.zip")) + list(edefter_dir.glob("*.xml"))
        if files:
            result["edefter"] = True
            result["edefter_count"] = len(files)
    elif raw_dir.exists():
        files = [f for f in raw_dir.glob("*") if "defter" in f.name.lower() or "berat" in f.name.lower()]
        if files:
            result["edefter"] = True
            result["edefter_count"] = len(files)

    return result


class Taxpayer(BaseModel):
    id: str
    name: str
    vkn: str  # Vergi Kimlik No (masked)
    active: bool = True


class Period(BaseModel):
    id: str
    label: str
    status: str  # active, closed, draft


class TaxpayerListResponse(BaseModel):
    schema_name: str = "taxpayer_list"
    version: str = "1.0"
    data: dict


class PeriodListResponse(BaseModel):
    schema_name: str = "period_list"
    version: str = "1.0"
    data: dict


class TaxpayerCreateRequest(BaseModel):
    """Request body for creating a new taxpayer"""
    name: str = Field(..., min_length=2, max_length=200, description="Firma adı")
    vkn: str = Field(..., min_length=10, max_length=11, description="VKN (10 hane) veya TCKN (11 hane)")
    type: Optional[str] = Field("limited", description="Şirket türü: limited, anonim, sahis")


class TaxpayerCreateResponse(BaseModel):
    schema_name: str = "taxpayer_create"
    version: str = "1.0"
    data: dict


def mask_vkn(tax_id: str) -> str:
    """Mask VKN for display (show first 3 and last 2 digits)"""
    if not tax_id or len(tax_id) < 5:
        return tax_id or "***"
    return f"{tax_id[:3]}****{tax_id[-2:]}"


def get_period_label(period_code: str) -> str:
    """Generate Turkish period label from code"""
    if not period_code or "-Q" not in period_code.upper():
        return period_code

    parts = period_code.upper().split("-Q")
    year = parts[0]
    quarter = int(parts[1])

    quarter_labels = {
        1: "Ocak-Mart",
        2: "Nisan-Haziran",
        3: "Temmuz-Eylül",
        4: "Ekim-Aralık"
    }

    month_range = quarter_labels.get(quarter, "")
    return f"{year} Q{quarter} ({month_range})"


def get_data_status(cursor, client_id: str, smmm_id: str = "HKOZKAN") -> dict:
    """
    Her mükellef için yüklü veri durumunu kontrol et
    SMMM'ler için kritik: Hangi dönemde hangi veri var?

    Database'de veri yoksa disk'teki dosyaları da kontrol eder (FALLBACK)
    """
    # Dönemleri al
    cursor.execute("""
        SELECT id, period_code, start_date, end_date, status
        FROM periods
        WHERE client_id = ?
        ORDER BY start_date DESC
    """, (client_id,))
    periods = cursor.fetchall()

    if not periods:
        return {
            "periods": [],
            "summary": {
                "total_periods": 0,
                "data_complete": False,
                "missing_data": ["Dönem tanımlı değil"]
            }
        }

    period_data = []
    for p in periods:
        period_id = p["period_code"] or p["id"]

        # Mizan verisi var mı? (Database)
        cursor.execute("""
            SELECT COUNT(*) as cnt FROM mizan_entries
            WHERE client_id = ? AND period_id = ?
        """, (client_id, period_id))
        mizan_count = cursor.fetchone()["cnt"]

        # Beyanname verisi var mı? (Database)
        cursor.execute("""
            SELECT COUNT(*) as cnt FROM beyanname_entries
            WHERE client_id = ? AND period_id = ?
        """, (client_id, period_id))
        beyanname_count = cursor.fetchone()["cnt"]

        # Banka verisi var mı? (Database)
        cursor.execute("""
            SELECT COUNT(*) as cnt FROM bank_transactions
            WHERE client_id = ? AND period_id = ?
        """, (client_id, period_id))
        banka_count = cursor.fetchone()["cnt"]

        # E-Defter verisi var mı? (Database)
        cursor.execute("""
            SELECT COUNT(*) as cnt FROM edefter_entries
            WHERE client_id = ? AND period_id = ?
        """, (client_id, period_id))
        edefter_count = cursor.fetchone()["cnt"]

        # Tahakkuk verisi var mı? (Database)
        cursor.execute("""
            SELECT COUNT(*) as cnt FROM tahakkuk_entries
            WHERE client_id = ? AND period_id = ?
        """, (client_id, period_id))
        tahakkuk_count = cursor.fetchone()["cnt"]

        # ═══════════════════════════════════════════════════════════════════════════
        # DISK FALLBACK: Database'de veri yoksa disk'teki dosyaları kontrol et
        # ═══════════════════════════════════════════════════════════════════════════
        db_has_data = mizan_count > 0 or beyanname_count > 0 or tahakkuk_count > 0
        if not db_has_data:
            disk_data = _check_disk_data(smmm_id, client_id, period_id, cursor)
            if disk_data["mizan"]:
                mizan_count = disk_data["mizan_count"] or 1
            if disk_data["beyanname"]:
                beyanname_count = disk_data["beyanname_count"]
            if disk_data["banka"]:
                banka_count = disk_data["banka_count"]
            if disk_data["edefter"]:
                edefter_count = disk_data["edefter_count"]
            if disk_data["tahakkuk"]:
                tahakkuk_count = disk_data["tahakkuk_count"]

        # Feed items (analiz sonuçları) var mı?
        cursor.execute("""
            SELECT COUNT(*) as cnt FROM feed_items
            WHERE client_id = ? AND period_id = ?
        """, (client_id, period_id))
        feed_result = cursor.fetchone()
        feed_count = feed_result["cnt"] if feed_result else 0

        period_data.append({
            "id": p["id"],  # Benzersiz DB ID (CLIENT_048_1EFCED87_2025-Q1)
            "period_id": period_id,  # Period code (2025-Q1) - for data queries
            "period_label": get_period_label(period_id),
            "status": p["status"],
            "data": {
                "mizan": mizan_count > 0,
                "mizan_count": mizan_count,
                "beyanname": beyanname_count > 0,
                "beyanname_count": beyanname_count,
                "banka": banka_count > 0,
                "banka_count": banka_count,
                "edefter": edefter_count > 0,
                "edefter_count": edefter_count,
                "tahakkuk": tahakkuk_count > 0,
                "tahakkuk_count": tahakkuk_count,
            },
            "analysis": {
                "has_results": feed_count > 0,
                "finding_count": feed_count
            }
        })

    # Özet hesapla
    has_any_mizan = any(p["data"]["mizan"] for p in period_data)
    complete_periods = sum(1 for p in period_data if p["data"]["mizan"])

    missing = []
    if not has_any_mizan:
        missing.append("Mizan verisi yüklenmemiş")

    return {
        "periods": period_data,
        "summary": {
            "total_periods": len(period_data),
            "complete_periods": complete_periods,
            "data_complete": complete_periods == len(period_data) and len(period_data) > 0,
            "has_mizan": has_any_mizan,
            "missing_data": missing if missing else None
        }
    }


@router.get("/{tenant_id}/taxpayers")
async def list_taxpayers(tenant_id: str, user: dict = Depends(verify_token)):
    """
    List all taxpayers (mükellef) for a tenant (SMMM office)

    Reads from clients table in database.
    Includes data status for each taxpayer (Sprint 6: SMMM Transparency)
    """
    conn = get_db()
    cursor = conn.cursor()

    try:
        # Get clients for this SMMM (tenant)
        cursor.execute("""
            SELECT id, name, tax_id
            FROM clients
            WHERE smmm_id = ? OR smmm_id IS NULL
            ORDER BY name
        """, (tenant_id,))

        rows = cursor.fetchall()

        taxpayers = []
        for row in rows:
            data_status = get_data_status(cursor, row["id"], smmm_id=tenant_id)
            taxpayers.append({
                "id": row["id"],
                "name": row["name"],
                "vkn": mask_vkn(row["tax_id"]),
                "vkn_full": row["tax_id"],  # For internal use
                "active": True,
                "data_status": data_status
            })

        return {
            "schema": {"name": "taxpayer_list", "version": "1.0"},
            "data": {"taxpayers": taxpayers}
        }

    finally:
        conn.close()


@router.get("/{tenant_id}/taxpayers/{taxpayer_id}/periods")
async def list_periods(tenant_id: str, taxpayer_id: str, user: dict = Depends(verify_token)):
    """
    List available periods for a taxpayer

    Reads from periods table in database.
    """
    conn = get_db()
    cursor = conn.cursor()

    try:
        # Verify taxpayer exists
        cursor.execute("SELECT id FROM clients WHERE id = ?", (taxpayer_id,))
        if not cursor.fetchone():
            raise HTTPException(status_code=404, detail=f"Mükellef bulunamadı: {taxpayer_id}")

        # Get periods for this client
        cursor.execute("""
            SELECT id, period_code, start_date, end_date, status
            FROM periods
            WHERE client_id = ?
            ORDER BY start_date DESC
        """, (taxpayer_id,))

        rows = cursor.fetchall()

        periods = [
            {
                "id": row["period_code"] or row["id"],
                "label": get_period_label(row["period_code"] or row["id"]),
                "status": row["status"] or "active"
            }
            for row in rows
        ]

        return {
            "schema": {"name": "period_list", "version": "1.0"},
            "data": {"periods": periods, "taxpayer_id": taxpayer_id}
        }

    finally:
        conn.close()


@router.post("/{tenant_id}/taxpayers")
async def create_taxpayer(
    tenant_id: str,
    request: TaxpayerCreateRequest,
    user: dict = Depends(verify_token)
):
    """
    Create a new taxpayer (mükellef) for a tenant (SMMM office)

    Sprint 7: SMMM can add new taxpayers
    """
    conn = get_db()
    cursor = conn.cursor()

    try:
        # VKN validation
        vkn = request.vkn.strip()
        if not vkn.isdigit():
            raise HTTPException(status_code=400, detail="VKN sadece rakam içermelidir")

        if len(vkn) not in [10, 11]:
            raise HTTPException(status_code=400, detail="VKN 10 (tüzel) veya 11 (gerçek kişi) hane olmalıdır")

        # Check for duplicate VKN
        cursor.execute("SELECT id, name FROM clients WHERE tax_id = ?", (vkn,))
        existing = cursor.fetchone()
        if existing:
            raise HTTPException(
                status_code=400,
                detail=f"Bu VKN ile kayıtlı mükellef zaten var: {existing['name']}"
            )

        # Generate unique ID
        client_id = f"CLIENT_{vkn[:3]}_{uuid.uuid4().hex[:8].upper()}"

        # Insert new taxpayer
        cursor.execute("""
            INSERT INTO clients (id, name, tax_id, smmm_id, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (
            client_id,
            request.name.strip(),
            vkn,
            tenant_id,
            datetime.now().isoformat(),
            datetime.now().isoformat()
        ))

        conn.commit()

        # Return created taxpayer with data status
        data_status = get_data_status(cursor, client_id)

        taxpayer = {
            "id": client_id,
            "name": request.name.strip(),
            "vkn": mask_vkn(vkn),
            "vkn_full": vkn,
            "active": True,
            "data_status": data_status
        }

        return {
            "schema": {"name": "taxpayer_create", "version": "1.0"},
            "data": {"taxpayer": taxpayer, "message": "Mükellef başarıyla eklendi"}
        }

    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=f"Mükellef eklenirken hata oluştu: {str(e)}")
    finally:
        conn.close()


@router.delete("/{tenant_id}/taxpayers/{taxpayer_id}")
async def delete_taxpayer(
    tenant_id: str,
    taxpayer_id: str,
    user: dict = Depends(verify_token)
):
    """
    Delete a taxpayer (mükellef) and all related data

    Sprint 7: SMMM can remove taxpayers
    WARNING: This permanently deletes all data for this taxpayer!
    """
    conn = get_db()
    cursor = conn.cursor()

    try:
        # Verify taxpayer exists and belongs to this tenant
        cursor.execute("""
            SELECT id, name FROM clients
            WHERE id = ? AND (smmm_id = ? OR smmm_id IS NULL)
        """, (taxpayer_id, tenant_id))

        client = cursor.fetchone()
        if not client:
            raise HTTPException(status_code=404, detail=f"Mükellef bulunamadı: {taxpayer_id}")

        client_name = client["name"]

        # Delete related data in order (due to foreign key constraints)
        deleted_records = {}

        # 1. Feed items (analysis results)
        cursor.execute("DELETE FROM feed_items WHERE client_id = ?", (taxpayer_id,))
        deleted_records["feed_items"] = cursor.rowcount

        # 2. Document uploads
        cursor.execute("DELETE FROM document_uploads WHERE client_id = ?", (taxpayer_id,))
        deleted_records["documents"] = cursor.rowcount

        # 3. Mizan entries
        cursor.execute("DELETE FROM mizan_entries WHERE client_id = ?", (taxpayer_id,))
        deleted_records["mizan_entries"] = cursor.rowcount

        # 4. Beyanname entries (KDV, Muhtasar, Geçici Vergi, etc.)
        cursor.execute("DELETE FROM beyanname_entries WHERE client_id = ?", (taxpayer_id,))
        deleted_records["beyanname_entries"] = cursor.rowcount

        # 5. Tahakkuk entries
        cursor.execute("DELETE FROM tahakkuk_entries WHERE client_id = ?", (taxpayer_id,))
        deleted_records["tahakkuk_entries"] = cursor.rowcount

        # 6. E-Defter entries (Yevmiye + Kebir XML verileri)
        cursor.execute("DELETE FROM edefter_entries WHERE client_id = ?", (taxpayer_id,))
        deleted_records["edefter_entries"] = cursor.rowcount

        # 7. Bank transactions
        cursor.execute("DELETE FROM bank_transactions WHERE client_id = ?", (taxpayer_id,))
        deleted_records["bank_transactions"] = cursor.rowcount

        # 8. Journal entries (Yevmiye - if separate table exists)
        try:
            cursor.execute("DELETE FROM journal_entries WHERE client_id = ?", (taxpayer_id,))
            deleted_records["journal_entries"] = cursor.rowcount
        except sqlite3.OperationalError:
            pass  # Table may not exist

        # 9. Ledger entries (Kebir - if separate table exists)
        try:
            cursor.execute("DELETE FROM ledger_entries WHERE client_id = ?", (taxpayer_id,))
            deleted_records["ledger_entries"] = cursor.rowcount
        except sqlite3.OperationalError:
            pass  # Table may not exist

        # 10. Periods
        cursor.execute("DELETE FROM periods WHERE client_id = ?", (taxpayer_id,))
        deleted_records["periods"] = cursor.rowcount

        # 11. Finally, delete the client
        cursor.execute("DELETE FROM clients WHERE id = ?", (taxpayer_id,))

        conn.commit()

        # Calculate total deleted
        total_deleted = sum(deleted_records.values())

        return {
            "schema": {"name": "taxpayer_delete", "version": "1.0"},
            "data": {
                "deleted_id": taxpayer_id,
                "deleted_name": client_name,
                "deleted_records": deleted_records,
                "total_deleted": total_deleted,
                "message": f"'{client_name}' mükellefi ve tüm verileri başarıyla silindi ({total_deleted} kayıt)"
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=f"Mükellef silinirken hata oluştu: {str(e)}")
    finally:
        conn.close()
